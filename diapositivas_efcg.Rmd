---
  title: "Mini curso: Análisis de enriquecimiento funcional de conjuntos de genes en R"
  author: Robert Castelo
  output:
    xaringan::moon_reader:
      css: [default, default-fonts, custom.css]
      seal: false
---

```{r setup, include=FALSE, cache=FALSE}
options(htmltools.dir.version = FALSE, width=80)
knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache=TRUE)

## from http://yihui.name/knitr/hooks#chunk_hooks
knitr::knit_hooks$set(small.mar=function(before, options, envir) {
                      if (before) par(mar=c(4, 5, 1, 1)) ## smaller margin on top and right
})
```

class: inverse, center, middle
background-image: url(img/portada_curso.jpg)
background-size: contain

---

class: title-slide, middle, center

# Mini curso: Análisis de enriquecimiento funcional de conjuntos de genes en R

.large[Robert Castelo]

.large[robert.castelo@upf.edu | @robertclab]

.large[Universidad Pompeu Fabra | Barcelona]

<img style="width:70px" src="img/logoUPFsmall.png"/>

---

# Vías biológicas diferencialmente expresadas

* La interpretación de una lista de genes diferencialmente expresados (DE) suele ser más util cuando la hacemos en términos de vías biológicas (_biological pathways_).

* Una **vía biológica** es una serie de acciones entre moléculas de una célula que conduce a un determinado producto o a un cambio en la célula; vean la página educacional correspondiente del
[NHGRI](https://www.genome.gov/es/about-genomics/fact-sheets/Vias-Biologicas) para una descripción más ámplia.

* Dado que los genes actúan colectivamente bajo el control de programas de regulación molecular, un modelo
más cercano a la biología subyacente es aquel en que las vías biológicas son las que se expresan diferencialmente.

* Una aproximación sería intentar hacer el análisis de expresión diferencial **directamente** a nivel de vía
biológica, o **indirectamente** buscando la sobre-representación (enriquecimiento) de nuestros genes DE en
cada vía de **interés**.

---

# Definiciones de vías biológicas

* Consideremos primero restrigir la búsqueda de vías biológicas DE a aquellas que son conocidas.

* Bases de datos como [Reactome](https://www.reactome.org) o [KEGG](https://www.genome.jp/kegg)
anotan información de la literatura sobre los genes, la proteinas and las reacciones que forman
las vías biológicas.

* Una forma simple pero muy útil de definir vías biológicas es en terminos de **conjuntos de genes**,
irrespectivamente de las interacciones moleculares que pueda haber entre ellos y/o sus productos.

* Hay muchas bases de datos de conjuntos de genes, siendo las más populares
[The Gene Ontology (GO) project](http://geneontology.org) y
[The Molecular Signatures Database (MSigDB)](https://www.gsea-msigdb.org/gsea/msigdb).

* A menudo las bases de datos no incluyen las vías biológicas que són más relevantes al sistema
que estamos estudiando. En tal caso, deberíamos de o bien curar nuestros propios conjuntos de genes,
o bien utilizar técnicas para inferirlos a partir de los datos.

---

# Definiciones de vías biológicas

* Por ejemplo, piensen en genes que codifican por proteinas involucradas en la respuesta inmune innata.
Concretamente, aquellos q detectan patógenos humanos.


.center2[
<img style="margin-top:20%" src="img/TLRs.jpg" width="400px"/>
]

.footnote[Fig. 1. Christmas P. Toll-Like Receptors: Sensors that Detect Infection. <a href="https://www.nature.com/scitable/topicpage/toll-like-receptors-sensors-that-detect-infection-14396559#"><em>Nature Education</em>, 3(9):85, 2010.</a>]

---

# Idea general del enriquecimiento functional

* Teniendo en mente la definición de la vía biológica previa, qué podríamos concluir a partir de la siguiente
gráfica de tipo volcán?

.center2[
<img style="margin-top:25%" src="img/CostaCastelo16fig1a.png" width="350px"/>
]

.footnote[Fig. 1a. Costa D and Castelo R. Umbilical cord gene expression reveals the molecular architecture of the fetal inflammatory response in extremely preterm newborns. <a href="https://dx.doi.org/10.1038/pr.2015.233"><em>Pediatric Research</em>, 79:473-481, 2016.</a>]

---

# Idea general del enriquecimiento functional

* Una forma conveniente de encontrar vías biológicas DE, en términos de conjuntos de genes DE, es detectando
lo que se suele llamar un **enriquecimiento funcional** a través de los siguientes dos pasos:
  <br>
  1. Buscar genes DE.
  2. Para cada conjunto de genes, verificar si esos genes DE pertenecen a ese conjunto
     en una proporción que excede cualquier expectativa de encontrar ese número de genes
     en ese conjunto únicamente por azar.

* En este contexto, cuando un conjunto de genes contiene **más** genes DE que los que podríamos esperar
por puro azar, decimos que este conjunto de genes esta **enriquecido** en genes DE.

* Una forma fácil de aplicar esta estrategia es utilizando la llamada
[prueba exacta de Fisher ](https://es.wikipedia.org/wiki/Prueba_exacta_de_Fisher)
(también conocida como prueba hipergeométrica).

---

# La prueba exacta de Fisher

* **Hipótesis nula**: el conjunto de genes no incluye más genes DE que los que podríamos esperar únicamente
por azar. Esta hipótesis nula se suele formalizar con el llamado **modelo de la urna**:

.left-column[
<img src="img/RenaissanceUrn.png" style="margin-left:10px; width:100%">
<img src="img/blackAndWhiteBalls.png" style="margin-left:10px; width:100%">
]

.right-column[
* Universo de genes: todos los genes que **consideramos**.
* Hay una bola en la urna para cada gen del universo de genes.
* Cada bola está etiquetada con un único identificador de gen.
* Las bolas blancas representan genes **DE**.
* Las bolas negras representan genes **no-DE**.
* Sacar a ciegas (uniformemente al azar) tantas bolas de la urna
  como genes tenemos en el conjunto de genes para el que hacemos la
  prueba, sin volverlas a poner en la urna (muestreo **sin reemplazamiento**).
* El número de **bolas blancas** sacadas de esta manera de la urna (i.e., el número
  de genes DE del conjunto para el que hacemos la prueba) sigue una
  [distribución hipergeométrica](https://es.wikipedia.org/wiki/Distribuci%C3%B3n_hipergeom%C3%A9trica).
]

---

# La prueba exacta de Fisher

* Consideramos las siguientes cantidades:

  * $N$ es el número total de genes __considerados__ (tamaño de nuestro universo de genes).
  * $n$ es el número de genes DE.
  * $m$ es el número de genes del conjunto para el que hacemos la prueba.
  * $k$ es el número de genes DE en el conjunto para el que hacemos la prueba.

* La [prueba exacta de Fisher](https://es.wikipedia.org/wiki/Prueba_exacta_de_Fisher)
se utiliza ampliamente en el análisis de tablas de contingencia resultantes de clasificar
objetos a través de dos factores los cuales en nuestro caso son la pertenencia a un conjunto
de genes y si un gen es DE o no:


GENES               | DE    | no-DE     | Total  
--------------------|-------|-----------|------
DENTRO DEL CONJUNTO |  $k$  | $m-k$     | $m$
FUERA DEL CONJUNTO  | $n-k$ | $N+k-n-m$ | $N-m$
TOTAL               | $n$   | $N-n$     | $N$

---

# La prueba exacta de Fisher

* Dados los valores $N$, $n$, $m$ y $k$ y una variable aleatoria $X$ representando los posibles
resultados del experimento con la urna, la probabilidad de observar exactamente $k$ genes en el
conjunto de genes para el que hacemos la prueba es:

$$ \textrm{Pr}(X=k) = \frac{ {m \choose k} {N-m \choose n-k} }{ N \choose n }\,. $$

* La probabilidad de observar $k$ **o más** genes DE en un conjunto de genes bajo la hipótesis
nula es:

$$ \textrm{Pr}(X >= k)=\sum_{x=k}^{\textrm{min}(m, n)} \frac{ {m\choose x} {N-m\choose n-x} }{ {N\choose n} }\,. $$
* Esta probabilidad corresponde al $p$-valor de una
[prueba exacta de Fisher](https://es.wikipedia.org/wiki/Prueba_exacta_de_Fisher) unilateral (_one-tailed_)
para la hipótesis nula de no-asociación entre dos factores.

* Este es el $p$-valor para la hipótesis nula de no-enriquecimiento de genes
DE en el conjunto de genes. Cuanto menor sea el $p$-valor, menos consistente con el puro azar
será la observación de los $k$ genes DE en el conjunto.

---

class: small-code

# La prueba exacta de Fisher

* Recordemos la fórmula de la probabilidad de observar $k$ **o mas** genes DE en un conjunto de genes bajo
la hipótesis nula:

$$ \textrm{Pr}(X >= k)=\sum_{x=k}^{\textrm{min}(m, n)} \frac{ {m\choose x} {N-m\choose n-x} }{ {N\choose n} }\,. $$

* Consideremos un ejemplo de juguete donde tenemos unos datos de expresión génica para $N=10$ genes,
de los cuales $m=4$ pertenecen a un conjunto de genes de nuestro interés y donde identificamos $n=2$
genes como DE. Supongamos que entre los $n=2$ genes DE hay $k=1$ que pertenece al conjunto de genes.
Cuál sería el $p$-valor que nos dice si este conjunto de genes esta enriquecido significativamente en
genes DE?

```{r}
N <- 10
m <- 4
n <- 2
k <- 1
choose(m, 1) * choose(N-m, n-1) / choose(N, n) + choose(m, 2) * choose(N-m, n-2) / choose(N, n)
```

---

class: small-code

# La prueba exacta de Fisher

* El cálculo anterior lo podemos hacer directamente utilizando la función de R `phyper()` para
calcular la masa de la distribución hipergeométrica de la siguiente forma:

```{r}
phyper(k-1, m, N-m, n, lower.tail=FALSE)
```

* Esto nos permite jugar facilmente con las cantidades involucradas en este cálculo, por ejemplo
aumentando el número de genes $N$ en nuestros datos de expresión.

```{r}
N <- 11
phyper(k-1, m, N-m, n, lower.tail=FALSE)
N <- 12
phyper(k-1, m, N-m, n, lower.tail=FALSE)
N <- 13
phyper(k-1, m, N-m, n, lower.tail=FALSE)
```

---

class: small-code

# La prueba exacta de Fisher

* El $p$-valor de la prueba depende del tamaño $N$ del universo de los genes!

```{r universeByN, fig.align="center", fig.width=5, fig.height=4, out.height="400px", small.mar=TRUE, dpi=300}
pn <- sapply(10:400, function(N) phyper(k-1, m, N-m, n, lower.tail=FALSE))
plot(10:400, pn, type="l", xlab="N", ylab="Pr(X>=k)", las=1, lwd=2, cex.axis=1.2, cex.lab=1.5)
abline(h=0.05, lty=3, lwd=2, col="red")
```

---

class: small-code

# La prueba exacta de Fisher

.pull-left[
* La función de R `fisher.test()` nos permite hacer la prueba exacta unilateral de Fisher de la
siguiente manera.

* Consideramos la organización previa de la tabla de contingencia de genes DE y de pertenecia a
un conjunto de genes:

.small-table[

GENES               | DE    | no-DE     | Total  
--------------------|-------|-----------|------
DENTRO DEL CONJUNTO |  $k$  | $m-k$     | $m$
FUERA DEL CONJUNTO  | $n-k$ | $N+k-n-m$ | $N-m$
TOTAL               | $n$   | $N-n$     | $N$

]

* Para llevar a cabo la prueba exacta de Fisher de forma **unilateral**, debemos utilizar el
parámetro `alternative="greater"`.
]

.pull-right[
```{r, tidy=FALSE}
N <- 10
dnames <- list(CG=c("dentro","fuera"),
               DE=c("sí","no"))
t <- matrix(c(k, n-k, m-k, N+k-n-m),
            nrow=2, ncol=2, dimnames=dnames)
t
fisher.test(t, alternative="greater")
```
]

---

class: small-code

# La prueba exacta de Fisher

<!--
<img style="margin-top:0%" src="img/TLRs.jpg" width="100%"/><br>
<img style="margin-top:0%" src="img/CostaCastelo16fig1a.png" width="100%"/>
-->

* Ejemplo con el [fichero de resultados](dat/ttFIRinELGANsUCtissue.rds) del
análisis de expresión diferencial de
[Costa and Castelo (2016)](https://dx.doi.org/10.1038/pr.2015.233).

```{r}
tt <- readRDS(file.path("dat", "ttFIRinELGANsUCtissue.rds"))
dim(tt)
head(tt, n=3)
```

* Identificamos genes DE (FDR < 1%, mínimo 50% de cambio) y formamos el conjunto de genes TLR.

```{r}
genesDE <- tt$Symbol[tt$adj.P.Val < 0.01 & abs(tt$logFC) > log2(1.5)]
length(genesDE)
head(genesDE)
TLRs <- tt$Symbol[grep("TLR", tt$Symbol)]
TLRs
```

---

class: small-code

# La prueba exacta de Fisher

* Construimos la tabla de contingencia y hacemos la prueba exacta de Fisher.

```{r}
m <- length(TLRs)
N <- nrow(tt)
n <- length(genesDE)
k <- length(intersect(genesDE, TLRs))
t <- matrix(c(k, n-k, m-k, N+k-n-m),
            nrow=2, ncol=2, dimnames=dnames)
t
fisher.test(t, alternative="greater")
```

---

# El análisis de _Gene Ontology_

* Un _análisis de Gene Ontology (GO)_ es un análisis de enriquecimiento funcional
aplicado a cada uno de los conjuntos de genes de la
[base de datos de GO](http://geneontology.org).

* La [base de datos de GO](http://geneontology.org) proporciona un vocabulario
controlado para describir atributos de genes y sus productos para cualquier organismo.
Consiste de los llamados **términos GO**, los cuales are pares de identificador de
término (GO ID) y su descripción.

|     GO ID | Descripción           |
|-----------|-----------------------|
|GO:0045087 | innate immune response|
|GO:0006955 | immune response       |
|GO:0006950 | response to stress    |

* Un término GO pertenece a una de las siguientes tres ontologías: _Biological Process (BP)_,
_Molecular Function (MF)_ y _Cellular Component (CC)_.

* El producto de un gen puede asociarse con o localizarse en uno o más **componentes celulares**
y estar activo en uno o más **procesos biológicos** durante los cuales realiza una o más
**funciones moleculares**.

---

# El análisis de _Gene Ontology_

.pull-left[

* Dentro de una ontología, los términos GO estan relacionados unos con otros a través de relaciones
jerárquicas que describen cuándo un término GO es más general que otro más específico.

* Detalles en este u otros aspectos están descritos en
[http://geneontology.org/docs/ontology-documentation](http://geneontology.org/docs/ontology-documentation)

* Para poder llevar a cabo un análisis de GO necesitamos anotaciones sobre los genes que nos
digan a qué términos GO están asociados.

]

.pull-right[
<img width="100%" src="img/GOinnateimmuneresponse.png"/>
]

---

class: small-code

# El análisis de _Gene Ontology_

* El paquete de Bioconductor [org.Hs.eg.db](https://bioconductor.org/packages/org.Hs.eg.db) contiene
anotaciones diversas para los genes humanos, incluyendo anotaciones de términos GO.

```{r}
library(org.Hs.eg.db)
allHumanGO <- select(org.Hs.eg.db, columns="GO", keys=keys(org.Hs.eg.db, keytype="SYMBOL"),
                     keytype="SYMBOL")
dim(allHumanGO)
head(allHumanGO, n=3)
```

* Las anotaciones de términos GO sobre los genes incluyen la trazabilidad del origen de la
anotación mediante los [códigos de evidencia](http://geneontology.org/docs/guide-go-evidence-codes).

```{r}
sort(table(allHumanGO$EVIDENCE), decreasing=TRUE)
```

---

class: small-code

# El análisis de _Gene Ontology_

* Contrastamos si el término GO _innate immune response_ (GO:0045087)
está enriquecido con los genes DE de
[Costa and Castelo (2016)](https://dx.doi.org/10.1038/pr.2015.233).

```{r}
genesIIR <- allHumanGO$SYMBOL[allHumanGO$GO %in% "GO:0045087"]
m <- length(intersect(genesIIR, tt$Symbol)) ## incluir sólo genes analizados en el conjunto
k <- length(intersect(genesDE, genesIIR))
t <- matrix(c(k, n-k, m-k, N+k-n-m),
            nrow=2, ncol=2, dimnames=dnames)
t
fisher.test(t, alternative="greater")
```

---

# El análisis de _Gene Ontology_

* Hay miles de conjuntos de genes definidos por los términos GO.

```{r}
length(unique(allHumanGO$GO))
```

* Existen múltiples paquetes de R disponibles en
[CRAN](https://cran.r-project.org) y [Bioconductor](https://bioconductor.org)
que permiten llevar a cabo un análisis de enriquecimiento funcional automáticamente
para todos los términos GO.

* Aquí ilustraremos este tipo de análisis con el paquete
[GOstats](https://bioconductor.org/packages/GOstats).

```{r}
library(GOstats)
```

* Con
[GOstats](https://bioconductor.org/packages/GOstats)
el análisis consiste de los siguientes tres pasos:

  1. Construir un **objeto** de parámetros que especifican información como cuál es
  el universo de los genes, que genes consideramos DE, etc.
  2. Ejecutar el análisis de enriquecimiento funcional.
  3. Almacenar y visualizar los resultados.
  
---

class: small-code

# El análisis de _Gene Ontology_

* Construimos un objeto de parámetros utilizando identificadores
[Entrez Gene](https://doi.org/10.1093/nar/gkl993) para los genes:

```{r}
universoEntrez <- rownames(tt)
genesDEentrez <- rownames(tt)[tt$adj.P.Val < 0.01 & abs(tt$logFC) > log2(1.5)]
params <- new("GOHyperGParams", geneIds=genesDEentrez, universeGeneIds=universoEntrez,
              annotation="org.Hs.eg.db", ontology="BP", pvalueCutoff=0.01)
```

* Ejecutamos el análisis de enriquecimiento funcional (dura unos minutos).

```{r}
hgOver <- hyperGTest(params)
hgOver
```

* Almacenamos y visualizamos los [resultados](analisisGO.html).

```{r}
htmlReport(hgOver, file="analisisGO.html")
```
```{r, eval=FALSE}
browseURL("analisisGO.html")
```

---

class: small-code

# El análisis de _Gene Ontology_

* El objeto retornado por `hyperGTest()` pertenece la clase
`GOHyperGResult`. La página de ayuda de `HyperGResult-accessors`
contiene información sobre qué métodos se pueden utilizar para
explorar los resultados programáticamente.

```{r, eval=FALSE}
help("HyperGResult-accessors")
```

* Un método muy útil es `summary()` ya que nos proporciona un objeto
`data.frame` con los resultados de la prueba exacta de Fisher para cada
término GO que cumple el umbral del $p$-valor especificado en el objeto
de parámetros.

```{r}
resHgOver <- summary(hgOver)
dim(resHgOver)
head(resHgOver, n=3)
```

---

class: small-code

# El análisis de _Gene Ontology_

* Otros métodos de acceso a los resultados son.

```{r}
head(geneCounts(hgOver))
head(universeCounts(hgOver))
head(pvalues(hgOver))
length(pvalues(hgOver))
```

* Estos métodos proporcionan los resultados de las pruebas realizadas
**todos** los términos GO, y no solamente a los que tienen un $p$-valor
debajo del umbral utilizado.

---

class: small-code

# El análisis de _Gene Ontology_

.pull-left[

* La jerarquía de términos GO y sus solapamientos hacen que las pruebas
de hipótesis sean muy dependientes entre ellas.

* Si un término está enriquecido significativamente, es probable que el
término inmediamente superior también lo esté, y sin embargo el término
más específico siempre será más relevante.

* Una solución consiste en analizar de los términos más específicos a los
más generales, eliminando los genes que enriquecen un término significativo,
del término inmediatamente más general en la jerarquía
([Alexa et al., 2006](https://doi.org/10.1093/bioinformatics/btl140)).

]

.pull-right[
<img width="100%" src="img/GOinnateimmuneresponse.png"/>
]

---

class: small-code

# El análisis de _Gene Ontology_

* En el paquete
[GOstats](https://bioconductor.org/packages/GOstats)
esta estrategia se puede utilizar configurando el argumento
`conditional=TRUE` en el objeto de parámetros.

```{r}
conditional(params) <- TRUE
```

* Luego procedimos exactamente igual que hicimos antes.

```{r}
hgOverCond <- hyperGTest(params)
hgOverCond
htmlReport(hgOverCond, file="analisisGOcondicional.html")
```

* En esta nueva [tabla de resultados](analisisGOcondicional.html),
el número de términos GO significativos es menor que cuando utilizamos
la prueba _incondicional_ (`conditional=FALSE`).

---

class: small-code

# El análisis de _Gene Ontology_

* Los términos GO anotados en pocos genes (e.g., $m < 3$) o enriquecidos
también por pocos genes (e.g., $k < 3$) son menos fiables que los que
involucran más genes. Por otro lado, los términos GO anotados a muchos
genes (e.g., $m > 300$) pueden ser demasiado generales para resultar
útiles.

* Para intentar identificar los términos GO enriquecidos más interesantes
y fiables podemos filtrar los resultados de la siguiente forma.

```{r}
resGO <- summary(hgOverCond)
resGO <- resGO[resGO$Size >= 5 & resGO$Size <= 300 & resGO$Count >= 5, ]
resGO <- resGO[order(resGO$OddsRatio, decreasing=TRUE), ]
head(resGO)
```

---

class: small-code

# El análisis de _Gene Ontology_

* Mediante el método `geneIdsByCategory()` podemos extraer los genes que
_enriquecen_ cada término GO y pegarlos al resultado de la siguiente manera.

```{r}
idGenes <- geneIdsByCategory(hgOverCond)[resGO$GOBPID]
simGenes <- sapply(idGenes, function(ids) tt[ids, "Symbol"])
simGenes <- sapply(simGenes, paste, collapse=", ")
resGO <- cbind(resGO, Genes=simGenes)
rownames(resGO) <- 1:nrow(resGO)
```

* Podemos generar una tabla de resultados con toda esta información mediante
la funcion `kable` del paquete
[knitr](https://cran.r-project.org/package=knitr) y las funciones
`kable_styling()` y `save_kable()` del paquete
[kableExtra](https://cran.r-project.org/package=kableExtra).

```{r}
library(knitr)
library(kableExtra)

ktab <- kable(resGO, "html", caption="Resultados análisis GO.", row.names=TRUE)
ktab <- kable_styling(ktab, bootstrap_options=c("stripped", "hover", "responsive"),
                      fixed_thead=TRUE)
save_kable(ktab, file="analisisGOfiltrado.html", self_contained=TRUE)
```

* La tabla de resultados se puede ver a través de este
[enlace](analisisGOfiltrado.html).

---

# Observaciones finales

* Un análisis de enriquecimiento funcional es una manera fácil de
abordar la cuestión de qué vías biológicas pueden estar DE.

* Este tipo de técnicas están limitadas por la cantidad de genes DE
que podemos obtener de nuestros datos.

* El número total de genes involucrados en los cálculos
(el _universo de los genes_) tiene influencia en el $p$-valor de la
prueba exacta de Fisher.

* Cuando hacemos un análisis de GO puede ser importante hacerlo teniendo en
cuenta la estructura jerárquica de la ontología de GO.

* Las bases de datos de conjuntos de genes no siempre pueden contener
aquellos conjuntos más relevantes a la biología del sistema que estamos
estudiando.

---

class: small-code

# Session information

```{r}
sessionInfo()
```