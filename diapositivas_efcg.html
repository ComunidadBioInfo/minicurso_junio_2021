<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Mini curso: Análisis de enriquecimiento funcional de conjuntos de genes en R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Robert Castelo" />
    <script src="diapositivas_efcg_files/header-attrs/header-attrs.js"></script>
    <link href="diapositivas_efcg_files/remark-css/default.css" rel="stylesheet" />
    <link href="diapositivas_efcg_files/remark-css/default-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




class: inverse, center, middle
background-image: url(img/portada_curso.jpg)
background-size: contain

---

class: title-slide, middle, center

# Mini curso: Análisis de enriquecimiento funcional de conjuntos de genes en R

.large[Robert Castelo]

.large[robert.castelo@upf.edu | @robertclab]

.large[Universidad Pompeu Fabra | Barcelona]

&lt;img style="width:70px" src="img/logoUPFsmall.png"/&gt;

---

# Vías biológicas diferencialmente expresadas

* La interpretación de una lista de genes diferencialmente expresados (DE) suele ser más util cuando la hacemos en términos de vías biológicas (_biological pathways_).

* Una **vía biológica** es una serie de acciones entre moléculas de una célula que conduce a un determinado producto o a un cambio en la célula; vean la página educacional correspondiente del
[NHGRI](https://www.genome.gov/es/about-genomics/fact-sheets/Vias-Biologicas) para una descripción más ámplia.

* Dado que los genes actúan colectivamente bajo el control de programas de regulación molecular, un modelo
más cercano a la biología subyacente es aquel en que las vías biológicas son las que se expresan diferencialmente.

* Una aproximación sería intentar hacer el análisis de expresión diferencial **directamente** a nivel de vía
biológica, o **indirectamente** buscando la sobre-representación (enriquecimiento) de nuestros genes DE en
cada vía de **interés**.

---

# Definiciones de vías biológicas

* Consideremos primero restrigir la búsqueda de vías biológicas DE a aquellas que son conocidas.

* Bases de datos como [Reactome](https://www.reactome.org) o [KEGG](https://www.genome.jp/kegg)
anotan información de la literatura sobre los genes, la proteínas y las reacciones que forman
las vías biológicas.

* Una forma simple pero muy útil de definir vías biológicas es en términos de **conjuntos de genes**,
independientemente de las interacciones moleculares que pueda haber entre ellos y/o sus productos.

* Hay muchas bases de datos de conjuntos de genes, siendo las más populares
[The Gene Ontology (GO) project](http://geneontology.org) y
[The Molecular Signatures Database (MSigDB)](https://www.gsea-msigdb.org/gsea/msigdb).

* A menudo las bases de datos no incluyen las vías biológicas que són más relevantes al sistema
que estamos estudiando. En tal caso, deberíamos de o bien curar nuestros propios conjuntos de genes,
o bien utilizar técnicas para inferirlos a partir de los datos.

---

# Definiciones de vías biológicas

* Por ejemplo, piensen en genes que codifican proteínas involucradas en la respuesta inmune innata.
Concretamente, aquellos que detectan patógenos humanos.


.center2[
&lt;img style="margin-top:20%" src="img/TLRs.jpg" width="400px"/&gt;
]

.footnote[Fig. 1. Christmas P. Toll-Like Receptors: Sensors that Detect Infection. &lt;a href="https://www.nature.com/scitable/topicpage/toll-like-receptors-sensors-that-detect-infection-14396559#"&gt;&lt;em&gt;Nature Education&lt;/em&gt;, 3(9):85, 2010.&lt;/a&gt;]

---

# Idea general del enriquecimiento funcional

* Teniendo en mente la definición de la vía biológica previa, qué podríamos concluir a partir de la siguiente
gráfica de tipo volcán?

.center2[
&lt;img style="margin-top:25%" src="img/CostaCastelo16fig1a.png" width="350px"/&gt;
]

.footnote[Fig. 1a. Costa D and Castelo R. Umbilical cord gene expression reveals the molecular architecture of the fetal inflammatory response in extremely preterm newborns. &lt;a href="https://dx.doi.org/10.1038/pr.2015.233"&gt;&lt;em&gt;Pediatric Research&lt;/em&gt;, 79:473-481, 2016.&lt;/a&gt;]

---

# Idea general del enriquecimiento funcional

* Una forma conveniente de encontrar vías biológicas DE, en términos de conjuntos de genes DE, es detectando
lo que se suele llamar un **enriquecimiento funcional** a través de los siguientes dos pasos:
  &lt;br&gt;
  1. Buscar genes DE.
  2. Para cada conjunto de genes, verificar si esos genes DE pertenecen a ese conjunto
     en una proporción que excede cualquier expectativa de encontrar ese número de genes
     en ese conjunto únicamente por azar.

* En este contexto, cuando un conjunto de genes contiene **más** genes DE que los que podríamos esperar
por puro azar, decimos que este conjunto de genes esta **enriquecido** en genes DE.

* Una forma fácil de aplicar esta estrategia es utilizando la llamada
[prueba exacta de Fisher ](https://es.wikipedia.org/wiki/Prueba_exacta_de_Fisher)
(también conocida como prueba hipergeométrica).

---

# La prueba exacta de Fisher

* **Hipótesis nula**: el conjunto de genes no incluye más genes DE que los que podríamos esperar únicamente
por azar. Esta hipótesis nula se suele formalizar con el llamado **modelo de la urna**:

.left-column[
&lt;img src="img/RenaissanceUrn.png" style="margin-left:10px; width:100%"&gt;
&lt;img src="img/blackAndWhiteBalls.png" style="margin-left:10px; width:100%"&gt;
]

.right-column[
* Universo de genes: todos los genes que **consideramos**.
* Hay una bola en la urna para cada gen del universo de genes.
* Cada bola está etiquetada con un único identificador de gen.
* Las bolas blancas representan genes **DE**.
* Las bolas negras representan genes **no-DE**.
* Sacar a ciegas (uniformemente al azar) tantas bolas de la urna
  como genes tenemos en el conjunto de genes para el que hacemos la
  prueba, sin volverlas a poner en la urna (muestreo **sin reemplazamiento**).
* El número de **bolas blancas** sacadas de esta manera de la urna (i.e., el número
  de genes DE del conjunto para el que hacemos la prueba) sigue una
  [distribución hipergeométrica](https://es.wikipedia.org/wiki/Distribuci%C3%B3n_hipergeom%C3%A9trica).
]

---

# La prueba exacta de Fisher

* Consideramos las siguientes cantidades:

  * `\(N\)` es el número total de genes __considerados__ (tamaño de nuestro universo de genes).
  * `\(n\)` es el número de genes DE.
  * `\(m\)` es el número de genes del conjunto para el que hacemos la prueba.
  * `\(k\)` es el número de genes DE en el conjunto para el que hacemos la prueba.

* La [prueba exacta de Fisher](https://es.wikipedia.org/wiki/Prueba_exacta_de_Fisher)
se utiliza ampliamente en el análisis de tablas de contingencia resultantes de clasificar
objetos a través de dos factores los cuales en nuestro caso son la pertenencia a un conjunto
de genes y si un gen es DE o no:


GENES               | DE    | no-DE     | Total  
--------------------|-------|-----------|------
DENTRO DEL CONJUNTO |  `\(k\)`  | `\(m-k\)`     | `\(m\)`
FUERA DEL CONJUNTO  | `\(n-k\)` | `\(N+k-n-m\)` | `\(N-m\)`
TOTAL               | `\(n\)`   | `\(N-n\)`     | `\(N\)`

---

# La prueba exacta de Fisher

* Dados los valores `\(N\)`, `\(n\)`, `\(m\)` y `\(k\)` y una variable aleatoria `\(X\)` representando los posibles
resultados del experimento con la urna, la probabilidad de observar exactamente `\(k\)` genes en el
conjunto de genes para el que hacemos la prueba es:

$$ \textrm{Pr}(X=k) = \frac{ {m \choose k} {N-m \choose n-k} }{ N \choose n }\,. $$

* La probabilidad de observar `\(k\)` **o más** genes DE en un conjunto de genes bajo la hipótesis
nula es:

$$ \textrm{Pr}(X &gt;= k)=\sum_{x=k}^{\textrm{min}(m, n)} \frac{ {m\choose x} {N-m\choose n-x} }{ {N\choose n} }\,. $$
* Esta probabilidad corresponde al `\(p\)`-valor de una
[prueba exacta de Fisher](https://es.wikipedia.org/wiki/Prueba_exacta_de_Fisher) unilateral (_one-tailed_)
para la hipótesis nula de no-asociación entre dos factores.

* Este es el `\(p\)`-valor para la hipótesis nula de no-enriquecimiento de genes
DE en el conjunto de genes. Cuanto menor sea el `\(p\)`-valor, menos consistente con el puro azar
será la observación de los `\(k\)` genes DE en el conjunto.

---

class: small-code

# La prueba exacta de Fisher

* Recordemos la fórmula de la probabilidad de observar `\(k\)` **o mas** genes DE en un conjunto de genes bajo
la hipótesis nula:

$$ \textrm{Pr}(X &gt;= k)=\sum_{x=k}^{\textrm{min}(m, n)} \frac{ {m\choose x} {N-m\choose n-x} }{ {N\choose n} }\,. $$

* Consideremos un ejemplo de juguete donde tenemos unos datos de expresión génica para `\(N=10\)` genes,
de los cuales `\(m=4\)` pertenecen a un conjunto de genes de nuestro interés y donde identificamos `\(n=2\)`
genes como DE. Supongamos que entre los `\(n=2\)` genes DE hay `\(k=1\)` que pertenece al conjunto de genes.
Cuál sería el `\(p\)`-valor que nos dice si este conjunto de genes está enriquecido significativamente en
genes DE?


```r
N &lt;- 10
m &lt;- 4
n &lt;- 2
k &lt;- 1
choose(m, 1) * choose(N-m, n-1) / choose(N, n) + choose(m, 2) * choose(N-m, n-2) / choose(N, n)
```

```
## [1] 0.6666667
```

---

class: small-code

# La prueba exacta de Fisher

* El cálculo anterior lo podemos hacer directamente utilizando la función de R `phyper()` para
calcular la masa de la distribución hipergeométrica de la siguiente forma:


```r
phyper(k-1, m, N-m, n, lower.tail=FALSE)
```

```
## [1] 0.6666667
```

* Esto nos permite jugar fácilmente con las cantidades involucradas en este cálculo, por ejemplo
aumentando el número de genes `\(N\)` en nuestros datos de expresión.


```r
N &lt;- 11
phyper(k-1, m, N-m, n, lower.tail=FALSE)
```

```
## [1] 0.6181818
```

```r
N &lt;- 12
phyper(k-1, m, N-m, n, lower.tail=FALSE)
```

```
## [1] 0.5757576
```

```r
N &lt;- 13
phyper(k-1, m, N-m, n, lower.tail=FALSE)
```

```
## [1] 0.5384615
```

---

class: small-code

# La prueba exacta de Fisher

* El `\(p\)`-valor de la prueba depende del tamaño `\(N\)` del universo de los genes!


```r
pn &lt;- sapply(10:400, function(N) phyper(k-1, m, N-m, n, lower.tail=FALSE))
plot(10:400, pn, type="l", xlab="N", ylab="Pr(X&gt;=k)", las=1, lwd=2, cex.axis=1.2, cex.lab=1.5)
abline(h=0.05, lty=3, lwd=2, col="red")
```

&lt;img src="diapositivas_efcg_files/figure-html/universeByN-1.png" height="400px" style="display: block; margin: auto;" /&gt;

---

class: small-code

# La prueba exacta de Fisher

.pull-left[
* La función de R `fisher.test()` nos permite hacer la prueba exacta unilateral de Fisher de la
siguiente manera.

* Consideramos la organización previa de la tabla de contingencia de genes DE y de pertenecia a
un conjunto de genes:

.small-table[

GENES               | DE    | no-DE     | Total  
--------------------|-------|-----------|------
DENTRO DEL CONJUNTO |  `\(k\)`  | `\(m-k\)`     | `\(m\)`
FUERA DEL CONJUNTO  | `\(n-k\)` | `\(N+k-n-m\)` | `\(N-m\)`
TOTAL               | `\(n\)`   | `\(N-n\)`     | `\(N\)`

]

* Para llevar a cabo la prueba exacta de Fisher de forma **unilateral**, debemos utilizar el
parámetro `alternative="greater"`.
]

.pull-right[

```r
N &lt;- 10
dnames &lt;- list(CG=c("dentro","fuera"),
               DE=c("sí","no"))
t &lt;- matrix(c(k, n-k, m-k, N+k-n-m),
            nrow=2, ncol=2, dimnames=dnames)
t
```

```
##         DE
## CG       sí no
##   dentro  1  3
##   fuera   1  5
```

```r
fisher.test(t, alternative="greater")
```

```
## 
## 	Fisher's Exact Test for Count Data
## 
## data:  t
## p-value = 0.6667
## alternative hypothesis: true odds ratio is greater than 1
## 95 percent confidence interval:
##  0.03262857        Inf
## sample estimates:
## odds ratio 
##   1.581082
```
]

---

class: small-code

# La prueba exacta de Fisher

&lt;!--
&lt;img style="margin-top:0%" src="img/TLRs.jpg" width="100%"/&gt;&lt;br&gt;
&lt;img style="margin-top:0%" src="img/CostaCastelo16fig1a.png" width="100%"/&gt;
--&gt;

* Ejemplo con el [fichero de resultados](dat/ttFIRinELGANsUCtissue.rds) del
análisis de expresión diferencial de
[Costa and Castelo (2016)](https://dx.doi.org/10.1038/pr.2015.233).


```r
tt &lt;- readRDS(file.path("dat", "ttFIRinELGANsUCtissue.rds"))
dim(tt)
```

```
## [1] 20155     7
```

```r
head(tt, n=3)
```

```
##       Symbol    logFC  AveExpr        t      P.Value    adj.P.Val        B
## 6347    CCL2 3.727625 8.205631 14.23615 1.511172e-16 3.045768e-12 27.32118
## 7357    UGCG 1.700702 8.510050 13.39688 9.946626e-16 1.002371e-11 25.54257
## 10135  NAMPT 2.933293 9.458513 12.18658 1.737891e-14 1.089489e-10 22.81971
```

* Identificamos genes DE (FDR &lt; 1%, mínimo 50% de cambio) y formamos el conjunto de genes TLR.


```r
genesDE &lt;- tt$Symbol[tt$adj.P.Val &lt; 0.01 &amp; abs(tt$logFC) &gt; log2(1.5)]
length(genesDE)
```

```
## [1] 1088
```

```r
head(genesDE)
```

```
## [1] "CCL2"   "UGCG"   "NAMPT"  "CNTN1"  "S100A9" "FGF13"
```

```r
TLRs &lt;- tt$Symbol[grep("TLR", tt$Symbol)]
TLRs
```

```
##  [1] "TLR8"     "TLR5"     "TLR2"     "TLR4"     "TLR1"     "TLR6"    
##  [7] "TLR7"     "TLR3"     "TLR10"    "TLR9"     "TLR8-AS1"
```

---

class: small-code

# La prueba exacta de Fisher

* Construimos la tabla de contingencia y hacemos la prueba exacta de Fisher.


```r
m &lt;- length(TLRs)
N &lt;- nrow(tt)
n &lt;- length(genesDE)
k &lt;- length(intersect(genesDE, TLRs))
t &lt;- matrix(c(k, n-k, m-k, N+k-n-m),
            nrow=2, ncol=2, dimnames=dnames)
t
```

```
##         DE
## CG         sí    no
##   dentro    2     9
##   fuera  1086 19058
```

```r
fisher.test(t, alternative="greater")
```

```
## 
## 	Fisher's Exact Test for Count Data
## 
## data:  t
## p-value = 0.1159
## alternative hypothesis: true odds ratio is greater than 1
## 95 percent confidence interval:
##  0.6041142       Inf
## sample estimates:
## odds ratio 
##   3.899655
```

---

# El análisis de _Gene Ontology_

* Un _análisis de Gene Ontology (GO)_ es un análisis de enriquecimiento funcional
aplicado a cada uno de los conjuntos de genes de la
[base de datos de GO](http://geneontology.org).

* La [base de datos de GO](http://geneontology.org) proporciona un vocabulario
controlado para describir atributos de genes y sus productos para cualquier organismo.
Consiste de los llamados **términos GO**, los cuales son pares de identificador de
término (GO ID) y su descripción.

|     GO ID | Descripción           |
|-----------|-----------------------|
|GO:0045087 | innate immune response|
|GO:0006955 | immune response       |
|GO:0006950 | response to stress    |

* Un término GO pertenece a una de las siguientes tres ontologías: _Biological Process (BP)_,
_Molecular Function (MF)_ y _Cellular Component (CC)_.

* El producto de un gen puede asociarse con o localizarse en uno o más **componentes celulares**
y estar activo en uno o más **procesos biológicos** durante los cuales realiza una o más
**funciones moleculares**.

---

# El análisis de _Gene Ontology_

.pull-left[

* Dentro de una ontología, los términos GO están relacionados unos con otros a través de relaciones
jerárquicas que describen cuándo un término GO es más general que otro más específico.

* Detalles en este u otros aspectos están descritos en
[http://geneontology.org/docs/ontology-documentation](http://geneontology.org/docs/ontology-documentation)

* Para poder llevar a cabo un análisis de GO necesitamos anotaciones sobre los genes que nos
digan a qué términos GO están asociados.

]

.pull-right[
&lt;img width="100%" src="img/GOinnateimmuneresponse.png"/&gt;
]

---

class: small-code

# El análisis de _Gene Ontology_

* El paquete de Bioconductor [org.Hs.eg.db](https://bioconductor.org/packages/org.Hs.eg.db) contiene
anotaciones diversas para los genes humanos, incluyendo anotaciones de términos GO.


```r
library(org.Hs.eg.db)
allHumanGO &lt;- select(org.Hs.eg.db, columns="GO", keys=keys(org.Hs.eg.db, keytype="SYMBOL"),
                     keytype="SYMBOL")
dim(allHumanGO)
```

```
## [1] 375694      4
```

```r
head(allHumanGO, n=3)
```

```
##   SYMBOL         GO EVIDENCE ONTOLOGY
## 1   A1BG GO:0002576      TAS       BP
## 2   A1BG GO:0003674       ND       MF
## 3   A1BG GO:0005576      HDA       CC
```

* Las anotaciones de términos GO sobre los genes incluyen la trazabilidad del origen de la
anotación mediante los [códigos de evidencia](http://geneontology.org/docs/guide-go-evidence-codes).


```r
sort(table(allHumanGO$EVIDENCE), decreasing=TRUE)
```

```
## 
##   IEA   IDA   IBA   TAS   ISS   IMP   IPI   HDA   NAS   IGI    ND   ISA    IC 
## 70526 68654 63435 42473 26506 21884 18641  7541  6770  1867  1775  1452  1244 
##   IEP   EXP   HMP   RCA   HEP   ISO   ISM   IGC 
##   880   297   153   143    70     8     2     1
```

---

class: small-code

# El análisis de _Gene Ontology_

* Contrastamos si el término GO _innate immune response_ (GO:0045087)
está enriquecido con los genes DE de
[Costa and Castelo (2016)](https://dx.doi.org/10.1038/pr.2015.233).


```r
genesIIR &lt;- allHumanGO$SYMBOL[allHumanGO$GO %in% "GO:0045087"]
m &lt;- length(intersect(genesIIR, tt$Symbol)) ## incluir sólo genes analizados en el conjunto
k &lt;- length(intersect(genesDE, genesIIR))
t &lt;- matrix(c(k, n-k, m-k, N+k-n-m),
            nrow=2, ncol=2, dimnames=dnames)
t
```

```
##         DE
## CG         sí    no
##   dentro   61   352
##   fuera  1027 18715
```

```r
fisher.test(t, alternative="greater")
```

```
## 
## 	Fisher's Exact Test for Count Data
## 
## data:  t
## p-value = 7.436e-13
## alternative hypothesis: true odds ratio is greater than 1
## 95 percent confidence interval:
##  2.462727      Inf
## sample estimates:
## odds ratio 
##   3.157651
```

---

# El análisis de _Gene Ontology_

* Hay miles de conjuntos de genes definidos por los términos GO.


```r
length(unique(allHumanGO$GO))
```

```
## [1] 18392
```

* Existen múltiples paquetes de R disponibles en
[CRAN](https://cran.r-project.org) y [Bioconductor](https://bioconductor.org)
que permiten llevar a cabo un análisis de enriquecimiento funcional automáticamente
para todos los términos GO.

* Aquí ilustraremos este tipo de análisis con el paquete
[GOstats](https://bioconductor.org/packages/GOstats).


```r
library(GOstats)
```

* Con
[GOstats](https://bioconductor.org/packages/GOstats)
el análisis consiste de los siguientes tres pasos:

  1. Construir un **objeto** de parámetros que especifican información como cuál es
  el universo de los genes, qué genes consideramos DE, etc.
  2. Ejecutar el análisis de enriquecimiento funcional.
  3. Almacenar y visualizar los resultados.
  
---

class: small-code

# El análisis de _Gene Ontology_

* Construimos un objeto de parámetros utilizando identificadores
[Entrez Gene](https://doi.org/10.1093/nar/gkl993) para los genes:


```r
universoEntrez &lt;- rownames(tt)
genesDEentrez &lt;- rownames(tt)[tt$adj.P.Val &lt; 0.01 &amp; abs(tt$logFC) &gt; log2(1.5)]
params &lt;- new("GOHyperGParams", geneIds=genesDEentrez, universeGeneIds=universoEntrez,
              annotation="org.Hs.eg.db", ontology="BP", pvalueCutoff=0.01)
```

* Ejecutamos el análisis de enriquecimiento funcional (dura unos minutos).


```r
hgOver &lt;- hyperGTest(params)
hgOver
```

```
## Gene to GO BP  test for over-representation 
## 8069 GO BP ids tested (1338 have p &lt; 0.01)
## Selected gene set size: 1007 
##     Gene universe size: 15706 
##     Annotation package: org.Hs.eg
```

* Almacenamos y visualizamos los [resultados](analisisGO.html).


```r
htmlReport(hgOver, file="analisisGO.html")
```

```r
browseURL("analisisGO.html")
```

---

class: small-code

# El análisis de _Gene Ontology_

* El objeto retornado por `hyperGTest()` pertenece la clase
`GOHyperGResult`. La página de ayuda de `HyperGResult-accessors`
contiene información sobre qué métodos se pueden utilizar para
explorar los resultados programáticamente.


```r
help("HyperGResult-accessors")
```

* Un método muy útil es `summary()` ya que nos proporciona un objeto
`data.frame` con los resultados de la prueba exacta de Fisher para cada
término GO que cumple el umbral del `\(p\)`-valor especificado en el objeto
de parámetros.


```r
resHgOver &lt;- summary(hgOver)
dim(resHgOver)
```

```
## [1] 1338    7
```

```r
head(resHgOver, n=3)
```

```
##       GOBPID       Pvalue OddsRatio  ExpCount Count Size
## 1 GO:0006955 9.736341e-43  3.039817 121.81969   276 1900
## 2 GO:0002274 1.144643e-40  4.682485  40.39284   140  630
## 3 GO:0001775 6.453102e-39  3.269138  86.04317   215 1342
##                           Term
## 1              immune response
## 2 myeloid leukocyte activation
## 3              cell activation
```

---

class: small-code

# El análisis de _Gene Ontology_

* Otros métodos de acceso a los resultados son.


```r
head(geneCounts(hgOver))
```

```
## GO:0006955 GO:0002274 GO:0001775 GO:0002376 GO:0036230 GO:0042119 
##        276        140        215        342        117        116
```

```r
head(universeCounts(hgOver))
```

```
## GO:0006955 GO:0002274 GO:0001775 GO:0002376 GO:0036230 GO:0042119 
##       1900        630       1342       2761        486        481
```

```r
head(pvalues(hgOver))
```

```
##   GO:0006955   GO:0002274   GO:0001775   GO:0002376   GO:0036230   GO:0042119 
## 9.736341e-43 1.144643e-40 6.453102e-39 1.062898e-38 1.712818e-37 2.991395e-37
```

```r
length(pvalues(hgOver))
```

```
## [1] 8069
```

* Estos métodos proporcionan los resultados de las pruebas realizadas
**todos** los términos GO, y no solamente a los que tienen un `\(p\)`-valor
debajo del umbral utilizado.

---

class: small-code

# El análisis de _Gene Ontology_

.pull-left[

* La jerarquía de términos GO y sus solapamientos hacen que las pruebas
de hipótesis sean muy dependientes entre ellas.

* Si un término está enriquecido significativamente, es probable que el
término inmediamente superior también lo esté, y sin embargo el término
más específico siempre será más relevante.

* Una solución consiste en analizar de los términos más específicos a los
más generales, eliminando los genes que enriquecen un término significativo,
del término inmediatamente más general en la jerarquía
([Alexa et al., 2006](https://doi.org/10.1093/bioinformatics/btl140)).

]

.pull-right[
&lt;img width="100%" src="img/GOinnateimmuneresponse.png"/&gt;
]

---

class: small-code

# El análisis de _Gene Ontology_

* En el paquete
[GOstats](https://bioconductor.org/packages/GOstats)
esta estrategia se puede utilizar configurando el argumento
`conditional=TRUE` en el objeto de parámetros.


```r
conditional(params) &lt;- TRUE
```

* Luego procedimos exactamente igual que hicimos antes.


```r
hgOverCond &lt;- hyperGTest(params)
hgOverCond
```

```
## Gene to GO BP Conditional test for over-representation 
## 8069 GO BP ids tested (745 have p &lt; 0.01)
## Selected gene set size: 1007 
##     Gene universe size: 15706 
##     Annotation package: org.Hs.eg
```

```r
htmlReport(hgOverCond, file="analisisGOcondicional.html")
```

* En esta nueva [tabla de resultados](analisisGOcondicional.html),
el número de términos GO significativos es menor que cuando utilizamos
la prueba _incondicional_ (`conditional=FALSE`).

---

class: small-code

# El análisis de _Gene Ontology_

* Los términos GO anotados en pocos genes (e.g., `\(m &lt; 3\)`) o enriquecidos
también por pocos genes (e.g., `\(k &lt; 3\)`) son menos fiables que los que
involucran más genes. Por otro lado, los términos GO anotados a muchos
genes (e.g., `\(m &gt; 300\)`) pueden ser demasiado generales para resultar
útiles.

* Para intentar identificar los términos GO enriquecidos más interesantes
y fiables podemos filtrar los resultados de la siguiente forma.


```r
resGO &lt;- summary(hgOverCond)
resGO &lt;- resGO[resGO$Size &gt;= 5 &amp; resGO$Size &lt;= 300 &amp; resGO$Count &gt;= 5, ]
resGO &lt;- resGO[order(resGO$OddsRatio, decreasing=TRUE), ]
head(resGO)
```

```
##         GOBPID       Pvalue OddsRatio  ExpCount Count Size
## 105 GO:0010273 2.598197e-06  20.57160 0.7693875     7   12
## 59  GO:0045730 2.943982e-08  18.50176 1.1493022    10   18
## 199 GO:0010911 1.087535e-04  18.33209 0.5770406     5    9
## 119 GO:0002274 5.116181e-06  16.38870 0.8108681     7   14
## 46  GO:0010575 2.473519e-09  13.71838 1.7311219    13   27
## 146 GO:0097501 1.779072e-05  12.85463 0.9617344     7   15
##                                                                     Term
## 105                                         detoxification of copper ion
## 59                                                     respiratory burst
## 199                                     regulation of isomerase activity
## 119                                         myeloid leukocyte activation
## 46  positive regulation of vascular endothelial growth factor production
## 146                                         stress response to metal ion
```

---

class: small-code

# El análisis de _Gene Ontology_

* Mediante el método `geneIdsByCategory()` podemos extraer los genes que
_enriquecen_ cada término GO y pegarlos al resultado de la siguiente manera.


```r
idGenes &lt;- geneIdsByCategory(hgOverCond)[resGO$GOBPID]
simGenes &lt;- sapply(idGenes, function(ids) tt[ids, "Symbol"])
simGenes &lt;- sapply(simGenes, paste, collapse=", ")
resGO &lt;- cbind(resGO, Genes=simGenes)
rownames(resGO) &lt;- 1:nrow(resGO)
```

* Podemos generar una tabla de resultados con toda esta información mediante
la funcion `kable` del paquete
[knitr](https://cran.r-project.org/package=knitr) y las funciones
`kable_styling()` y `save_kable()` del paquete
[kableExtra](https://cran.r-project.org/package=kableExtra).


```r
library(knitr)
library(kableExtra)

ktab &lt;- kable(resGO, "html", caption="Resultados análisis GO.", row.names=TRUE)
ktab &lt;- kable_styling(ktab, bootstrap_options=c("stripped", "hover", "responsive"),
                      fixed_thead=TRUE)
save_kable(ktab, file="analisisGOfiltrado.html", self_contained=TRUE)
```

* La tabla de resultados se puede ver a través de este
[enlace](analisisGOfiltrado.html).

---

# Observaciones finales sobre enriquecimiento funcional con la prueba exacta de Fisher

* Un análisis de enriquecimiento funcional mediante la prueba exacta
unilateral de Fisher es una manera fácil de abordar la cuestión de
qué vías biológicas pueden estar DE.

* Este tipo de técnicas están limitadas por la cantidad de genes DE
que podemos obtener de nuestros datos.

* El número total de genes involucrados en los cálculos
(el _universo de los genes_) tiene influencia en el `\(p\)`-valor de la
prueba exacta de Fisher.

* Cuando llevamos a cabo un "análisis de GO" puede ser importante hacerlo
teniendo en cuenta la estructura jerárquica de la ontología de GO.

* Las bases de datos de conjuntos de genes no siempre pueden contener
aquellos conjuntos más relevantes a la biología del sistema que estamos
estudiando.

---

# Métodos GSEA

* Los métodos de enriquecimiento funcional basados en pruebas de
sobre-representación como la prueba exacta de Fisher, tienen la
limitación de que necesitan una lista mínimamente grande de genes DE (&gt;= 30).

* Existen contextos biológicos donde la magnitud de los cambios de
expresión diferencial puede ser pequeña y podemos llegar a identificar
solamente unos pocos genes DE (e.g., enfermedades complejas, biomarcadores).

* Hipótesis: los cambios moleculares más relevantes, si bien pequeños,
ocurren de forma coordinada en una misma vía biológica.

* GSEA es el acrónimo de _Gene Set Enrichment Analysis_ acuñado por
[Subramanian et al. (2005)](https://doi.org/10.1073/pnas.0506580102),
donde introducen un método para el análisis de enriquecimiento funcional
que parte de algún tipo de ranking de expresión diferencial, pero no
necesita un conjunto mínimo de genes DE.

* Desde entonces, han aparecido muchos otros métodos que parten del
conjunto de datos de expresión o de algún tipo de ranking de expresión
diferencial. A todos estos métodos se les conoce popularmente como
_métodos GSEA_.

---

# Métodos GSEA

* La idea detrás del algoritmo de
[Subramanian et al. (2005)](https://doi.org/10.1073/pnas.0506580102) consiste
en calcular para cada conjunto de genes una **puntuación de enriquecimiento**,
o _enrichment score_ (ES) en inglés, como función de la posición de los genes
del conjunto a lo largo de un ranking de cambios en la expresión génica.

.center2[
&lt;img style="margin-top:25%" src="img/GSEAfig1.jpg" width="400px"/&gt;
]

.footnote[Fig. 1. Subramanian et al. Gene set enrichment analysis: a knowledge-based
approach for interpreting genome-wide expression profiles. &lt;a href="https://doi.org/10.1073/pnas.0506580102"&gt;&lt;em&gt;PNAS&lt;/em&gt;, 15545-15550, 2005.&lt;/a&gt;]

---

# Métodos GSEA

* Una base de datos de conjuntos de genes muy importante es la
[Molecular Signatures Database (MSigDB)](https://www.gsea-msigdb.org/gsea/msigdb),
la cual proporciona conjuntos de genes organizados 9 grandes colecciones temáticas.

* MSigDB almacena cada colección de conjuntos de genes en un fichero en
un formato llamado
[_gene matrix transposed_ (GMT)](https://software.broadinstitute.org/cancer/software/gsea/wiki/index.php/Data_formats#GMT:_Gene_Matrix_Transposed_file_format_.28.2A.gmt.29).

   ```
   NOMBRE_DEL_CONJUNTO1 DESCRIPCION_CONJUNTO1 GEN1 GEN2 GEN3
   NOMBRE_DEL_CONJUNTO2 DESCRIPCION_CONJUNTO2 GEN4 GEN2 GEN5 GEN6 GEN7
   NOMBRE_DEL_CONJUNTO3 DESCRIPCION_CONJUNTO3 GEN1 GEN8 GEN9 GEN3
   ...
   ```

* El proyecto Bioconductor proporciona una infraestructura para facilitar la
manipulación de conjuntos de genes mediante el paquete
[GSEABase](https://bioconductor.org/packages/GSEABase). Este paquete incluye
la funcionalidad para importar en R ficheros GMT.


```r
library(GSEABase)
```

---

class: small-code

# Métodos GSEA

* Para importar ficheros de texto en formato GMT utilizamos la función
`getGmt()` sobre un fichero de extensión `.gmt` que hayamos bajado previamente
de MSigDb. Esta función nos retornará un objeto `GeneSetCollection`.


```r
c7url &lt;- "https://data.broadinstitute.org/gsea-msigdb/msigdb/release/7.4/c7.immunesigdb.v7.4.entrez.gmt"
download.file(c7url, file.path("dat", "c7.immunesigdb.v7.4.entrez.gmt"))
```

```r
c7 &lt;- getGmt(file.path("dat", "c7.immunesigdb.v7.4.entrez.gmt"),
             geneIdType=EntrezIdentifier("org.Hs.eg.db"),
             collectionType=BroadCollection(category="c7"))
c7
```

```
## GeneSetCollection
##   names: KAECH_NAIVE_VS_DAY8_EFF_CD8_TCELL_UP, KAECH_NAIVE_VS_DAY8_EFF_CD8_TCELL_DN, ..., GSE18804_SPLEEN_MACROPHAGE_VS_COLON_TUMORAL_MACROPHAGE_DN (4872 total)
##   unique identifiers: 359845, 272, ..., 353144 (20408 total)
##   types in collection:
##     geneIdType: EntrezIdentifier (1 total)
##     collectionType: BroadCollection (1 total)
```

```r
length(c7)
```

```
## [1] 4872
```

* Podemos obtener información sobre la clase de objetos `GeneSetCollection` en
su página de ayuda correspondiente:


```r
class ? GeneSetCollection
```

---

# Métodos GSEA

* Una de las ventajas de utilizar una clase de objetos específica para conjuntos
de genes es la facilidad para cambiar la nomenclatura de los identificadores de los
genes, por ejemplo, de _Entrez Gene_ a símbolos
[HGNC](https://www.genenames.org).


```r
c7sym &lt;- mapIdentifiers(c7, SymbolIdentifier())
c7sym
```

```
## GeneSetCollection
##   names: KAECH_NAIVE_VS_DAY8_EFF_CD8_TCELL_UP, KAECH_NAIVE_VS_DAY8_EFF_CD8_TCELL_DN, ..., GSE18804_SPLEEN_MACROPHAGE_VS_COLON_TUMORAL_MACROPHAGE_DN (4872 total)
##   unique identifiers: RFLNB, AMPD3, ..., LCE3C (20408 total)
##   types in collection:
##     geneIdType: SymbolIdentifier (1 total)
##     collectionType: BroadCollection (1 total)
```

```r
length(c7sym)
```

```
## [1] 4872
```


---

# Métodos GSEA

* Podemos sacar los conjuntos de genes en un objeto `list` con la función `geneIds()`.


```r
c7symlist &lt;- geneIds(c7sym)
head(lapply(c7symlist, head))
```

```
## $KAECH_NAIVE_VS_DAY8_EFF_CD8_TCELL_UP
## [1] "RFLNB" "AMPD3" "NSG2"  "DUSP6" "ADCY6" "TEC"  
## 
## $KAECH_NAIVE_VS_DAY8_EFF_CD8_TCELL_DN
## [1] "HOPX"   "ID2"    "LGALS1" "HASPIN" "NDUFV3" "S100A6"
## 
## $KAECH_NAIVE_VS_DAY15_EFF_CD8_TCELL_UP
## [1] "EML5"   "KLK8"   "GALK1"  "METTL9" "PRKD2"  "TDRP"  
## 
## $KAECH_NAIVE_VS_DAY15_EFF_CD8_TCELL_DN
## [1] "BCL2A1" "ID2"    "MAPRE2" "COX17"  "KLRG1"  "ITGAX" 
## 
## $KAECH_NAIVE_VS_MEMORY_CD8_TCELL_UP
## [1] "MFHAS1"  "PRKCB"   "RAMP1"   "RETREG1" "ADCY6"   "CNN3"   
## 
## $KAECH_NAIVE_VS_MEMORY_CD8_TCELL_DN
## [1] "TSPAN31" "CCR5"    "IFNG"    "FASLG"   "NRP1"    "ANXA2"
```

---

class: small-code

# Métodos GSEA

* Una vez tenemos un ranking the genes por cambios de expresión y una colección
de conjuntos de genes podemos llevar a cabo nuestro _análisis GSEA_.

* Existen muchos métodos GSEA, la implementación original de
[Subramanian et al. (2005)](https://doi.org/10.1073/pnas.0506580102) está
disponible en https://www.gsea-msigdb.org/gsea.

* Una implementación robusta y rápida es la del paquete de Bioconductor
[fgsea](https://bioconductor.org/packages/fgsea) introducida por
[Korotkevich et al. (2021)](https://doi.org/10.1101/060012).

* Para utilizarla debemos llamar a la funcion `fgsea()` con el conjunto de
genes en un objeto `list` y un vector numérico, típicamente con el estadistico
`\(t\)`, correspondiente al ranking de genes según su expresión diferencial.


```r
library(fgsea)

stats &lt;- tt$t
names(stats) &lt;- tt$Symbol
fgseares &lt;- fgsea(c7symlist, stats, minSize=10, maxSize=200)
```

---

class: small-code

# Métodos GSEA

* El valor retornado por la función `fgsea()` es un objeto `data.table`
(una versión sofisticada de un `data.frame`).


```r
head(fgseares)
```

```
##                                  pathway         pval         padj   log2err
## 1:   GOLDRATH_EFF_VS_MEMORY_CD8_TCELL_DN 6.048463e-02 9.558258e-02 0.3217759
## 2:   GOLDRATH_EFF_VS_MEMORY_CD8_TCELL_UP 1.393587e-04 5.435992e-04 0.5188481
## 3:    GOLDRATH_NAIVE_VS_EFF_CD8_TCELL_DN 1.418428e-05 7.274297e-05 0.5933255
## 4:    GOLDRATH_NAIVE_VS_EFF_CD8_TCELL_UP 4.996426e-02 8.207211e-02 0.3217759
## 5: GOLDRATH_NAIVE_VS_MEMORY_CD8_TCELL_DN 6.699955e-10 7.538610e-09 0.8012156
## 6: GOLDRATH_NAIVE_VS_MEMORY_CD8_TCELL_UP 1.868039e-02 3.583105e-02 0.3524879
##           ES      NES size                                leadingEdge
## 1: 0.2561817 1.213666  189    IL6ST,TNIP1,IL4R,SLC11A2,ITPR2,SELL,...
## 2: 0.3365420 1.596140  192      S100A8,LYN,XBP1,MT2A,ADAM8,TYROBP,...
## 3: 0.3689360 1.743882  188     MYO1F,LYN,BCL2A1,PLSCR1,EFHD2,MT2A,...
## 4: 0.2604265 1.234840  190      IL6ST,AMPD3,IL4R,BCL6,PTPN6,ITPR2,...
## 5: 0.4448640 2.109370  190 MYO1F,IER3,MAP3K8,BCL2A1,TNFRSF1B,CD44,...
## 6: 0.2751481 1.307017  191  NFKBIZ,PLAUR,HIF1A,IL6ST,AMPD3,TRIM25,...
```


---

class: small-code

# Métodos GSEA

* La columna `padj` contiene los `\(p\)`-valores corregidos por FDR, los cuales
podemos utilizar para seleccionar conjuntos de genes DE con, e.g., FDR &lt; 1%.


```r
fgsearesFDR1 &lt;- fgseares[fgseares$padj &lt; 0.01, ]
dim(fgsearesFDR1)
```

```
## [1] 1955    8
```

```r
orddec &lt;- order(abs(fgsearesFDR1$ES), decreasing=TRUE)
head(fgsearesFDR1[orddec, ], n=3)
```

```
##                                    pathway  pval         padj log2err        ES
## 1:   GSE22886_NAIVE_BCELL_VS_NEUTROPHIL_DN 1e-10 1.302674e-09      NA 0.7948721
## 2:         GSE45365_NK_CELL_VS_CD11B_DC_DN 1e-10 1.302674e-09      NA 0.7600713
## 3: GSE22886_NAIVE_CD8_TCELL_VS_MONOCYTE_DN 1e-10 1.302674e-09      NA 0.7445796
##         NES size                                leadingEdge
## 1: 3.772168  184 NAMPT,S100A9,BCL3,S100A8,S100A12,CXCL1,...
## 2: 3.603959  190 S100A9,TNFAIP3,TIMP1,S100A8,CXCL1,PTX3,...
## 3: 3.531366  192  S100A9,BCL3,S100A8,S100A12,ACSL1,FPR1,...
```

* El conjunto de genes entre los que enriquecen significativamente el ranking
(FDR &lt; 1%) con mayor valor absoluto de ES es
[GSE22886_NAIVE_BCELL_VS_NEUTROPHIL_DN](https://www.gsea-msigdb.org/gsea/msigdb/cards/GSE22886_NAIVE_BCELL_VS_NEUTROPHIL_DN).

---

class: small-code

# Métodos GSEA

* La función `plotEnrichment()` nos permite ver cómo se ha calculado el valor
de ES para un conjunto de genes concreto.


```r
plotEnrichment(c7symlist[["GSE22886_NAIVE_BCELL_VS_NEUTROPHIL_DN"]], stats) +
               ggplot2::ggtitle("GSE22886_NAIVE_BCELL_VS_NEUTROPHIL_DN")
```

&lt;img src="diapositivas_efcg_files/figure-html/enrichmentplot-1.png" height="400px" style="display: block; margin: auto;" /&gt;

---

class: small-code

# Métodos GSVA

* Un tipo muy útil de métodos para el análisis de expresión diferencial a nivel de
vías biológicas son aquellos que calculan el enriquecimiento funcional sobre
cada muestra de forma individual, se les conoce como
_single sample gene set enrichment (ssGSEA) methods_ o
_gene set variation analysis (GSVA) methods_.

* Estos métodos se basan en una idea conceptualmente muy sencilla pero muy
potente: transformar la matriz de valores de expresión de genes por muestras a
otra matriz de valores de expresión de conjuntos-de-genes por muestra.

* Los métodos de este tipo se pueden agrupar por la forma en que realizan la
transformación:

  * `\(z\)`-_scores_ [(Lee et al., 2008)](https://doi.org/10.1371/journal.pcbi.1000217).
  * _singular value decomposition (SVD)_  [(Tomfohr et al., 2005)](https://doi.org/10.1186/1471-2105-6-225).
  * _competitive KS random-walks_ [(Barbie et al., 2009)](https://doi.org/10.1038/nature08460) y
    [(Hänzelmann et al., 2013)](https://doi.org/10.1186/1471-2105-14-7).
  * _self-contained KS random-walks_ [(Foroutan et al., 2018)](https://doi.org/10.1186/s12859-018-2435-4).
  
* Los cuatro primeros están disponibles en el paquete
[GSVA](https://bioconductor.org/packages/GSVA), mientras que el último
está disponible en el paquete
[singscore](https://bioconductor.org/packages/singscore).

---

class: small-code

# Métodos GSVA

* El método GSVA se puede representar esquemáticamente de la siguiente forma.

&lt;br&gt;&lt;br&gt;


![](img/GSVAfig1.jpg)

.footnote[Fig. 1. Hänzelmann et al. GSVA: gene set variation analysis for microarray and RNA-seq data. &lt;a href="https://doi.org/10.1186/1471-2105-14-7"&gt;&lt;em&gt;BMC Bioinformatics&lt;/em&gt;, 14:7, 2013.&lt;/a&gt;]

---

class: small-code

# Métodos GSVA

Para ilustrar la aplicación del método GSVA, utilizaremos los datos de expresión
génica de
[Costa and Castelo (2016)](https://dx.doi.org/10.1038/pr.2015.233), ya normalizados
y almacenados en un [objeto SummarizedExperiment](dat/seFIRinELGANsUCtissue.rds).


```r
library(SummarizedExperiment)
se &lt;- readRDS(file.path("dat", "seFIRinELGANsUCtissue.rds"))
se
```

```
## class: SummarizedExperiment 
## dim: 20155 43 
## metadata(0):
## assays(1): ''
## rownames(20155): A1BG NAT2 ... CASP8AP2 SCO2
## rowData names(0):
## colnames(43): GSM213072 GSM213074 ... GSM213124 GSM213125
## colData names(3): FIR Sex Batch
```

```r
table(se$FIR, se$Sex)
```

```
##      
##       female male
##   no       8   17
##   yes      8   10
```

---

class: small-code

# Métodos GSVA

* Una vez cargado el paquete
[GSVA](https://bioconductor.org/packages/GSVA), llamaremos a la función
`gsva()` con los datos de expresión y una colección de conjuntos de genes,
de la siguiente manera.


```r
library(GSVA)
```

```r
GSexpr &lt;- gsva(assay(se), c7sym, min.sz=10, max.sz=200)
```


```r
class(GSexpr)
```

```
## [1] "matrix" "array"
```

```r
dim(GSexpr)
```

```
## [1] 4872   43
```

```r
GSexpr[1:5, 1:6]
```

```
##                                        GSM213072   GSM213074   GSM213075
## KAECH_NAIVE_VS_DAY8_EFF_CD8_TCELL_UP  -0.0317458 -0.03163242 -0.21851507
## KAECH_NAIVE_VS_DAY8_EFF_CD8_TCELL_DN  -0.3526195 -0.16009174 -0.06671368
## KAECH_NAIVE_VS_DAY15_EFF_CD8_TCELL_UP -0.1576768 -0.11214300 -0.14758394
## KAECH_NAIVE_VS_DAY15_EFF_CD8_TCELL_DN -0.2060782 -0.15998962 -0.05934764
## KAECH_NAIVE_VS_MEMORY_CD8_TCELL_UP    -0.1772390  0.01588483 -0.16946417
##                                         GSM213076 GSM213078  GSM213080
## KAECH_NAIVE_VS_DAY8_EFF_CD8_TCELL_UP  -0.31413382 0.1310327 0.04574326
## KAECH_NAIVE_VS_DAY8_EFF_CD8_TCELL_DN  -0.09133786 0.1715075 0.19029476
## KAECH_NAIVE_VS_DAY15_EFF_CD8_TCELL_UP -0.17121027 0.1246299 0.15355984
## KAECH_NAIVE_VS_DAY15_EFF_CD8_TCELL_DN -0.07804361 0.1461861 0.17008254
## KAECH_NAIVE_VS_MEMORY_CD8_TCELL_UP    -0.23660689 0.1751549 0.19014024
```

---

class: small-code

# Métodos GSVA

* Ahora podemos utilizar la matriz de valores de _single sample ES_ para,
por ejemplo, llevar a cabo un análisis de expresión diferencial directamente
a nivel de vía biológica con el paquete
[limma](https://bioconductor.org/packages/limma). Nuestro modelo lineal contempla
la exposición a la respuesta inflamatoria (FIR) como principal variable explicativa
y el sexo y el indicador de lote como covariables de ajuste.


```r
library(limma)

mod &lt;- model.matrix(~ FIR + Sex + Batch, colData(se))
fit &lt;- lmFit(GSexpr, mod)
fit &lt;- eBayes(fit)
ttGS &lt;- topTable(fit, coef="FIRyes", n=Inf)
head(ttGS, n=3)
```

```
##                                               logFC      AveExpr        t
## GSE15733_BM_VS_SPLEEN_MEMORY_CD4_TCELL_UP 0.3522650 -0.002452355 8.587642
## GSE22886_NAIVE_CD8_TCELL_VS_NEUTROPHIL_DN 0.3955689 -0.007038328 8.308684
## GSE22886_NAIVE_CD4_TCELL_VS_NEUTROPHIL_DN 0.4177466 -0.012859892 8.106628
##                                                P.Value    adj.P.Val        B
## GSE15733_BM_VS_SPLEEN_MEMORY_CD4_TCELL_UP 5.938653e-11 2.893312e-07 14.76733
## GSE22886_NAIVE_CD8_TCELL_VS_NEUTROPHIL_DN 1.475002e-10 3.593104e-07 13.90778
## GSE22886_NAIVE_CD4_TCELL_VS_NEUTROPHIL_DN 2.864531e-10 4.651999e-07 13.27974
```

```r
sum(ttGS$adj.P.Val &lt; 0.01)
```

```
## [1] 396
```

---

class: small-code

# Métodos GSVA

* Podemos explorar los resultados como si hubieramos hecho el análisis
a nivel de gen, pero la magnitud del cambio de expresión no se puede interpretar igual.


```r
par(mfrow=c(1, 2))
hist(ttGS$P.Value, xlab="P-value", main="")
volcanoplot(fit, coef="FIRyes")
```

&lt;img src="diapositivas_efcg_files/figure-html/volcanoplot-1.png" height="350px" style="display: block; margin: auto;" /&gt;

---

# Observaciones finales sobre enriquecimiento funcional con GSEA y GSVA

* Los métodos GSEA condensan los perfiles de expresión en vías biológicas.
Nos permiten detectar cambios de expresión pequeños pero consistentes y
facilitan la interpretabilidad de los resultados.

* La principal ventaja de los métodos GSEA es que no dependen de una lista
de genes DE y esto es importante cuando la magnitud de los cambios de expresión
es pequeña en el sistema biológico que estemos estudiando.

* Hay muchos métodos GSEA, los artículos de revisión de
[Goeman and Buhlmann (2007)](https://doi.org/10.1093/bioinformatics/btm051), [Hung et al. (2012)](https://doi.org/10.1093/bib/bbr049) y [Geistlinger et al. (2020)](https://doi.org/10.1093/bib/bbz158) pueden servir como guía para
escoger el más adecuado para la cuestión que se desea abordar.

* Hemos utilizado métodos de filtrado no-específico para conjuntos de genes
que únicamente restringen el tamaño de estos conjuntos. Otras estrategias
que pudiesen eliminar conjuntos de genes irrelevantes para nuestro análisis
probablemente reducirían falsos positivos e incrementarían la potencia
estadística.

---

class: small-code

# Session information


```r
sessionInfo()
```

```
## R version 4.1.0 (2021-05-18)
## Platform: x86_64-apple-darwin17.0 (64-bit)
## Running under: macOS Big Sur 10.16
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRblas.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats4    parallel  stats     graphics  grDevices utils     datasets 
## [8] methods   base     
## 
## other attached packages:
##  [1] limma_3.48.0                GSVA_1.40.1                
##  [3] SummarizedExperiment_1.22.0 GenomicRanges_1.44.0       
##  [5] GenomeInfoDb_1.28.0         MatrixGenerics_1.4.0       
##  [7] matrixStats_0.59.0          fgsea_1.18.0               
##  [9] GSEABase_1.54.0             annotate_1.70.0            
## [11] XML_3.99-0.6                kableExtra_1.3.4           
## [13] knitr_1.33                  GO.db_3.13.0               
## [15] GOstats_2.58.0              graph_1.70.0               
## [17] Category_2.58.0             Matrix_1.3-4               
## [19] org.Hs.eg.db_3.13.0         AnnotationDbi_1.54.1       
## [21] IRanges_2.26.0              S4Vectors_0.30.0           
## [23] Biobase_2.52.0              BiocGenerics_0.38.0        
## 
## loaded via a namespace (and not attached):
##  [1] colorspace_2.0-1            ellipsis_0.3.2             
##  [3] XVector_0.32.0              rstudioapi_0.13            
##  [5] xaringan_0.21               bit64_4.0.5                
##  [7] fansi_0.5.0                 xml2_1.3.2                 
##  [9] codetools_0.2-18            splines_4.1.0              
## [11] sparseMatrixStats_1.4.0     cachem_1.0.5               
## [13] jsonlite_1.7.2              png_0.1-7                  
## [15] HDF5Array_1.20.0            compiler_4.1.0             
## [17] httr_1.4.2                  assertthat_0.2.1           
## [19] fastmap_1.1.0               BiocSingular_1.8.1         
## [21] htmltools_0.5.1.1           tools_4.1.0                
## [23] rsvd_1.0.5                  gtable_0.3.0               
## [25] glue_1.4.2                  GenomeInfoDbData_1.2.6     
## [27] dplyr_1.0.6                 fastmatch_1.1-0            
## [29] Rcpp_1.0.6                  jquerylib_0.1.4            
## [31] vctrs_0.3.8                 Biostrings_2.60.1          
## [33] rhdf5filters_1.4.0          svglite_2.0.0              
## [35] DelayedMatrixStats_1.14.0   xfun_0.23                  
## [37] stringr_1.4.0               beachmat_2.8.0             
## [39] rvest_1.0.0                 lifecycle_1.0.0            
## [41] irlba_2.3.3                 zlibbioc_1.38.0            
## [43] scales_1.1.1                RBGL_1.68.0                
## [45] rhdf5_2.36.0                SingleCellExperiment_1.14.1
## [47] yaml_2.2.1                  memoise_2.0.0              
## [49] gridExtra_2.3               ggplot2_3.3.3              
## [51] sass_0.4.0                  stringi_1.6.2              
## [53] RSQLite_2.2.7               highr_0.9                  
## [55] genefilter_1.74.0           ScaledMatrix_1.0.0         
## [57] BiocParallel_1.26.0         rlang_0.4.11               
## [59] pkgconfig_2.0.3             systemfonts_1.0.2          
## [61] bitops_1.0-7                evaluate_0.14              
## [63] lattice_0.20-44             purrr_0.3.4                
## [65] Rhdf5lib_1.14.1             bit_4.0.4                  
## [67] tidyselect_1.1.1            AnnotationForge_1.34.0     
## [69] magrittr_2.0.1              R6_2.5.0                   
## [71] generics_0.1.0              DelayedArray_0.18.0        
## [73] DBI_1.1.1                   pillar_1.6.1               
## [75] survival_3.2-11             KEGGREST_1.32.0            
## [77] RCurl_1.98-1.3              tibble_3.1.2               
## [79] crayon_1.4.1                utf8_1.2.1                 
## [81] rmarkdown_2.8               grid_4.1.0                 
## [83] data.table_1.14.0           blob_1.2.1                 
## [85] Rgraphviz_2.36.0            digest_0.6.27              
## [87] webshot_0.5.2               xtable_1.8-4               
## [89] munsell_0.5.0               viridisLite_0.4.0          
## [91] bslib_0.2.5.1
```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create();
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
