<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Mini curso: Análisis de enriquecimiento funcional de conjuntos de genes en R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Robert Castelo" />
    <script src="diapositivas_efcg_files/header-attrs/header-attrs.js"></script>
    <link href="diapositivas_efcg_files/remark-css/default.css" rel="stylesheet" />
    <link href="diapositivas_efcg_files/remark-css/default-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




class: inverse, center, middle
background-image: url(img/portada_curso.jpg)
background-size: contain

---

class: title-slide, middle, center

# Mini curso: Análisis de enriquecimiento funcional de conjuntos de genes en R

.large[Robert Castelo]

.large[robert.castelo@upf.edu | @robertclab]

.large[Universidad Pompeu Fabra | Barcelona]

&lt;img style="width:70px" src="img/logoUPFsmall.png"/&gt;

---

# Vías biológicas diferencialmente expresadas

* La interpretación de una lista de genes diferencialmente expresados (DE) suele ser más util cuando la hacemos en términos de vías biológicas (_biological pathways_).

* Una **vía biológica** es una serie de acciones entre moléculas de una célula que conduce a un determinado producto o a un cambio en la célula; vean la página educacional correspondiente del
[NHGRI](https://www.genome.gov/es/about-genomics/fact-sheets/Vias-Biologicas) para una descripción más ámplia.

* Dado que los genes actúan colectivamente bajo el control de programas de regulación molecular, un modelo
más cercano a la biología subyacente es aquel en que las vías biológicas son las que se expresan diferencialmente.

* Una aproximación sería intentar hacer el análisis de expresión diferencial **directamente** a nivel de vía
biológica, o **indirectamente** buscando la sobre-representación (enriquecimiento) de nuestros genes DE en
cada vía de **interés**.

---

# Definiciones de vías biológicas

* Consideremos primero restrigir la búsqueda de vías biológicas DE a aquellas que son conocidas.

* Bases de datos como [Reactome](https://www.reactome.org) o [KEGG](https://www.genome.jp/kegg)
anotan información de la literatura sobre los genes, la proteinas and las reacciones que forman
las vías biológicas.

* Una forma simple pero muy útil de definir vías biológicas es en terminos de **conjuntos de genes**,
irrespectivamente de las interacciones moleculares que pueda haber entre ellos y/o sus productos.

* Hay muchas bases de datos de conjuntos de genes, siendo las más populares
[The Gene Ontology (GO) project](http://geneontology.org) y
[The Molecular Signatures Database (MSigDB)](https://www.gsea-msigdb.org/gsea/msigdb).

* A menudo las bases de datos no incluyen las vías biológicas que són más relevantes al sistema
que estamos estudiando. En tal caso, deberíamos de o bien curar nuestros propios conjuntos de genes,
o bien utilizar técnicas para inferirlos a partir de los datos.

---

# Definiciones de vías biológicas

* Por ejemplo, piensen en genes que codifican por proteinas involucradas en la respuesta inmune innata.
Concretamente, aquellos q detectan patógenos humanos.


.center2[
&lt;img style="margin-top:20%" src="img/TLRs.jpg" width="400px"/&gt;
]

.footnote[Fig. 1. Christmas P. Toll-Like Receptors: Sensors that Detect Infection. &lt;a href="https://www.nature.com/scitable/topicpage/toll-like-receptors-sensors-that-detect-infection-14396559#"&gt;&lt;em&gt;Nature Education&lt;/em&gt;, 3(9):85, 2010.&lt;/a&gt;]

---

# Idea general del enriquecimiento functional

* Teniendo en mente la definición de la vía biológica previa, qué podríamos concluir a partir de la siguiente
gráfica de tipo volcán?

.center2[
&lt;img style="margin-top:25%" src="img/CostaCastelo16fig1a.png" width="350px"/&gt;
]

.footnote[Fig. 1a. Costa D and Castelo R. Umbilical cord gene expression reveals the molecular architecture of the fetal inflammatory response in extremely preterm newborns. &lt;a href="https://dx.doi.org/10.1038/pr.2015.233"&gt;&lt;em&gt;Pediatric Research&lt;/em&gt;, 79:473-481, 2016.&lt;/a&gt;]

---

# Idea general del enriquecimiento functional

* Una forma conveniente de encontrar vías biológicas DE, en términos de conjuntos de genes DE, es detectando
lo que se suele llamar un **enriquecimiento funcional** a través de los siguientes dos pasos:
  &lt;br&gt;
  1. Buscar genes DE.
  2. Para cada conjunto de genes, verificar si esos genes DE pertenecen a ese conjunto
     en una proporción que excede cualquier expectativa de encontrar ese número de genes
     en ese conjunto únicamente por azar.

* En este contexto, cuando un conjunto de genes contiene **más** genes DE que los que podríamos esperar
por puro azar, decimos que este conjunto de genes esta **enriquecido** en genes DE.

* Una forma fácil de aplicar esta estrategia es utilizando la llamada
[prueba exacta de Fisher ](https://es.wikipedia.org/wiki/Prueba_exacta_de_Fisher)
(también conocida como prueba hipergeométrica).

---

# La prueba exacta de Fisher

* **Hipótesis nula**: el conjunto de genes no incluye más genes DE que los que podríamos esperar únicamente
por azar. Esta hipótesis nula se suele formalizar con el llamado **modelo de la urna**:

.left-column[
&lt;img src="img/RenaissanceUrn.png" style="margin-left:10px; width:100%"&gt;
&lt;img src="img/blackAndWhiteBalls.png" style="margin-left:10px; width:100%"&gt;
]

.right-column[
* Universo de genes: todos los genes que **consideramos**.
* Hay una bola en la urna para cada gen del universo de genes.
* Cada bola está etiquetada con un único identificador de gen.
* Las bolas blancas representan genes **DE**.
* Las bolas negras representan genes **no-DE**.
* Sacar a ciegas (uniformemente al azar) tantas bolas de la urna
  como genes tenemos en el conjunto de genes para el que hacemos la
  prueba, sin volverlas a poner en la urna (muestreo **sin reemplazamiento**).
* El número de **bolas blancas** sacadas de esta manera de la urna (i.e., el número
  de genes DE del conjunto para el que hacemos la prueba) sigue una
  [distribución hipergeométrica](https://es.wikipedia.org/wiki/Distribuci%C3%B3n_hipergeom%C3%A9trica).
]

---

# La prueba exacta de Fisher

* Consideramos las siguientes cantidades:

  * `\(N\)` es el número total de genes __considerados__ (tamaño de nuestro universo de genes).
  * `\(n\)` es el número de genes DE.
  * `\(m\)` es el número de genes del conjunto para el que hacemos la prueba.
  * `\(k\)` es el número de genes DE en el conjunto para el que hacemos la prueba.

* La [prueba exacta de Fisher](https://es.wikipedia.org/wiki/Prueba_exacta_de_Fisher)
se utiliza ampliamente en el análisis de tablas de contingencia resultantes de clasificar
objetos a través de dos factores los cuales en nuestro caso son la pertenencia a un conjunto
de genes y si un gen es DE o no:


GENES               | DE    | no-DE     | Total  
--------------------|-------|-----------|------
DENTRO DEL CONJUNTO |  `\(k\)`  | `\(m-k\)`     | `\(m\)`
FUERA DEL CONJUNTO  | `\(n-k\)` | `\(N+k-n-m\)` | `\(N-m\)`
TOTAL               | `\(n\)`   | `\(N-n\)`     | `\(N\)`

---

# La prueba exacta de Fisher

* Dados los valores `\(N\)`, `\(n\)`, `\(m\)` y `\(k\)` y una variable aleatoria `\(X\)` representando los posibles
resultados del experimento con la urna, la probabilidad de observar exactamente `\(k\)` genes en el
conjunto de genes para el que hacemos la prueba es:

$$ \textrm{Pr}(X=k) = \frac{ {m \choose k} {N-m \choose n-k} }{ N \choose n }\,. $$

* La probabilidad de observar `\(k\)` **o más** genes DE en un conjunto de genes bajo la hipótesis
nula es:

$$ \textrm{Pr}(X &gt;= k)=\sum_{x=k}^{\textrm{min}(m, n)} \frac{ {m\choose x} {N-m\choose n-x} }{ {N\choose n} }\,. $$
* Esta probabilidad corresponde al `\(p\)`-valor de una
[prueba exacta de Fisher](https://es.wikipedia.org/wiki/Prueba_exacta_de_Fisher) unilateral (_one-tailed_)
para la hipótesis nula de no-asociación entre dos factores.

* Este es el `\(p\)`-valor para la hipótesis nula de no-enriquecimiento de genes
DE en el conjunto de genes. Cuanto menor sea el `\(p\)`-valor, menos consistente con el puro azar
será la observación de los `\(k\)` genes DE en el conjunto.

---

class: small-code

# La prueba exacta de Fisher

* Recordemos la fórmula de la probabilidad de observar `\(k\)` **o mas** genes DE en un conjunto de genes bajo
la hipótesis nula:

$$ \textrm{Pr}(X &gt;= k)=\sum_{x=k}^{\textrm{min}(m, n)} \frac{ {m\choose x} {N-m\choose n-x} }{ {N\choose n} }\,. $$

* Consideremos un ejemplo de juguete donde tenemos unos datos de expresión génica para `\(N=10\)` genes,
de los cuales `\(m=4\)` pertenecen a un conjunto de genes de nuestro interés y donde identificamos `\(n=2\)`
genes como DE. Supongamos que entre los `\(n=2\)` genes DE hay `\(k=1\)` que pertenece al conjunto de genes.
Cuál sería el `\(p\)`-valor que nos dice si este conjunto de genes esta enriquecido significativamente en
genes DE?


```r
N &lt;- 10
m &lt;- 4
n &lt;- 2
k &lt;- 1
choose(m, 1) * choose(N-m, n-1) / choose(N, n) + choose(m, 2) * choose(N-m, n-2) / choose(N, n)
```

```
## [1] 0.6666667
```

---

class: small-code

# La prueba exacta de Fisher

* El cálculo anterior lo podemos hacer directamente utilizando la función de R `phyper()` para
calcular la masa de la distribución hipergeométrica de la siguiente forma:


```r
phyper(k-1, m, N-m, n, lower.tail=FALSE)
```

```
## [1] 0.6666667
```

* Esto nos permite jugar facilmente con las cantidades involucradas en este cálculo, por ejemplo
aumentando el número de genes `\(N\)` en nuestros datos de expresión.


```r
N &lt;- 11
phyper(k-1, m, N-m, n, lower.tail=FALSE)
```

```
## [1] 0.6181818
```

```r
N &lt;- 12
phyper(k-1, m, N-m, n, lower.tail=FALSE)
```

```
## [1] 0.5757576
```

```r
N &lt;- 13
phyper(k-1, m, N-m, n, lower.tail=FALSE)
```

```
## [1] 0.5384615
```

---

class: small-code

# La prueba exacta de Fisher

* El `\(p\)`-valor de la prueba depende del tamaño `\(N\)` del universo de los genes!


```r
pn &lt;- sapply(10:400, function(N) phyper(k-1, m, N-m, n, lower.tail=FALSE))
plot(10:400, pn, type="l", xlab="N", ylab="Pr(X&gt;=k)", las=1, lwd=2, cex.axis=1.2, cex.lab=1.5)
abline(h=0.05, lty=3, lwd=2, col="red")
```

&lt;img src="diapositivas_efcg_files/figure-html/universeByN-1.png" height="400px" style="display: block; margin: auto;" /&gt;

---

class: small-code

# La prueba exacta de Fisher

.pull-left[
* La función de R `fisher.test()` nos permite hacer la prueba exacta unilateral de Fisher de la
siguiente manera.

* Consideramos la organización previa de la tabla de contingencia de genes DE y de pertenecia a
un conjunto de genes:

.small-table[

GENES               | DE    | no-DE     | Total  
--------------------|-------|-----------|------
DENTRO DEL CONJUNTO |  `\(k\)`  | `\(m-k\)`     | `\(m\)`
FUERA DEL CONJUNTO  | `\(n-k\)` | `\(N+k-n-m\)` | `\(N-m\)`
TOTAL               | `\(n\)`   | `\(N-n\)`     | `\(N\)`

]

* Para llevar a cabo la prueba exacta de Fisher de forma **unilateral**, debemos utilizar el
parámetro `alternative="greater"`.
]

.pull-right[

```r
N &lt;- 10
dnames &lt;- list(CG=c("dentro","fuera"),
               DE=c("sí","no"))
t &lt;- matrix(c(k, n-k, m-k, N+k-n-m),
            nrow=2, ncol=2, dimnames=dnames)
t
```

```
##         DE
## CG       sí no
##   dentro  1  3
##   fuera   1  5
```

```r
fisher.test(t, alternative="greater")
```

```
## 
## 	Fisher's Exact Test for Count Data
## 
## data:  t
## p-value = 0.6667
## alternative hypothesis: true odds ratio is greater than 1
## 95 percent confidence interval:
##  0.03262857        Inf
## sample estimates:
## odds ratio 
##   1.581082
```
]

---

class: small-code

# La prueba exacta de Fisher

&lt;!--
&lt;img style="margin-top:0%" src="img/TLRs.jpg" width="100%"/&gt;&lt;br&gt;
&lt;img style="margin-top:0%" src="img/CostaCastelo16fig1a.png" width="100%"/&gt;
--&gt;

* Ejemplo con el [fichero de resultados](dat/ttFIRinELGANsUCtissue.rds) del
análisis de expresión diferencial de
[Costa and Castelo (2016)](https://dx.doi.org/10.1038/pr.2015.233).


```r
tt &lt;- readRDS(file.path("dat", "ttFIRinELGANsUCtissue.rds"))
dim(tt)
```

```
## [1] 20155     7
```

```r
head(tt, n=3)
```

```
##       Symbol    logFC  AveExpr        t      P.Value    adj.P.Val        B
## 6347    CCL2 3.727625 8.205631 14.23615 1.511172e-16 3.045768e-12 27.32118
## 7357    UGCG 1.700702 8.510050 13.39688 9.946626e-16 1.002371e-11 25.54257
## 10135  NAMPT 2.933293 9.458513 12.18658 1.737891e-14 1.089489e-10 22.81971
```

* Identificamos genes DE (FDR &lt; 1%, mínimo 50% de cambio) y formamos el conjunto de genes TLR.


```r
genesDE &lt;- tt$Symbol[tt$adj.P.Val &lt; 0.01 &amp; abs(tt$logFC) &gt; log2(1.5)]
length(genesDE)
```

```
## [1] 1088
```

```r
head(genesDE)
```

```
## [1] "CCL2"   "UGCG"   "NAMPT"  "CNTN1"  "S100A9" "FGF13"
```

```r
TLRs &lt;- tt$Symbol[grep("TLR", tt$Symbol)]
TLRs
```

```
##  [1] "TLR8"     "TLR5"     "TLR2"     "TLR4"     "TLR1"     "TLR6"    
##  [7] "TLR7"     "TLR3"     "TLR10"    "TLR9"     "TLR8-AS1"
```

---

class: small-code

# La prueba exacta de Fisher

* Construimos la tabla de contingencia y hacemos la prueba exacta de Fisher.


```r
m &lt;- length(TLRs)
N &lt;- nrow(tt)
n &lt;- length(genesDE)
k &lt;- length(intersect(genesDE, TLRs))
t &lt;- matrix(c(k, n-k, m-k, N+k-n-m),
            nrow=2, ncol=2, dimnames=dnames)
t
```

```
##         DE
## CG         sí    no
##   dentro    2     9
##   fuera  1086 19058
```

```r
fisher.test(t, alternative="greater")
```

```
## 
## 	Fisher's Exact Test for Count Data
## 
## data:  t
## p-value = 0.1159
## alternative hypothesis: true odds ratio is greater than 1
## 95 percent confidence interval:
##  0.6041142       Inf
## sample estimates:
## odds ratio 
##   3.899655
```

---

# El análisis de _Gene Ontology_

* Un _análisis de Gene Ontology (GO)_ es un análisis de enriquecimiento funcional
aplicado a cada uno de los conjuntos de genes de la
[base de datos de GO](http://geneontology.org).

* La [base de datos de GO](http://geneontology.org) proporciona un vocabulario
controlado para describir atributos de genes y sus productos para cualquier organismo.
Consiste de los llamados **términos GO**, los cuales are pares de identificador de
término (GO ID) y su descripción.

|     GO ID | Descripción           |
|-----------|-----------------------|
|GO:0045087 | innate immune response|
|GO:0006955 | immune response       |
|GO:0006950 | response to stress    |

* Un término GO pertenece a una de las siguientes tres ontologías: _Biological Process (BP)_,
_Molecular Function (MF)_ y _Cellular Component (CC)_.

* El producto de un gen puede asociarse con o localizarse en uno o más **componentes celulares**
y estar activo en uno o más **procesos biológicos** durante los cuales realiza una o más
**funciones moleculares**.

---

# El análisis de _Gene Ontology_

.pull-left[

* Dentro de una ontología, los términos GO estan relacionados unos con otros a través de relaciones
jerárquicas que describen cuándo un término GO es más general que otro más específico.

* Detalles en este u otros aspectos están descritos en
[http://geneontology.org/docs/ontology-documentation](http://geneontology.org/docs/ontology-documentation)

* Para poder llevar a cabo un análisis de GO necesitamos anotaciones sobre los genes que nos
digan a qué términos GO están asociados.

]

.pull-right[
&lt;img width="100%" src="img/GOinnateimmuneresponse.png"/&gt;
]

---

class: small-code

# El análisis de _Gene Ontology_

* El paquete de Bioconductor [org.Hs.eg.db](https://bioconductor.org/packages/org.Hs.eg.db) contiene
anotaciones diversas para los genes humanos, incluyendo anotaciones de términos GO.


```r
library(org.Hs.eg.db)
allHumanGO &lt;- select(org.Hs.eg.db, columns="GO", keys=keys(org.Hs.eg.db, keytype="SYMBOL"),
                     keytype="SYMBOL")
dim(allHumanGO)
```

```
## [1] 379747      4
```

```r
head(allHumanGO, n=3)
```

```
##   SYMBOL         GO EVIDENCE ONTOLOGY
## 1   A1BG GO:0002576      TAS       BP
## 2   A1BG GO:0003674       ND       MF
## 3   A1BG GO:0005576      HDA       CC
```

* Las anotaciones de términos GO sobre los genes incluyen la trazabilidad del origen de la
anotación mediante los [códigos de evidencia](http://geneontology.org/docs/guide-go-evidence-codes).


```r
sort(table(allHumanGO$EVIDENCE), decreasing=TRUE)
```

```
## 
##   IEA   IDA   IBA   TAS   ISS   IMP   IPI   HDA   NAS    ND   IGI   ISA    IC 
## 75662 67065 65238 42573 25859 21384 18230  7571  6701  1811  1802  1485  1242 
##   IEP   ISM   EXP   HMP   RCA   HEP   ISO   IGC 
##   880   723   299   154   143    70     8     1
```

---

class: small-code

# El análisis de _Gene Ontology_

* Contrastamos si el término GO _innate immune response_ (GO:0045087)
está enriquecido con los genes DE de
[Costa and Castelo (2016)](https://dx.doi.org/10.1038/pr.2015.233).


```r
genesIIR &lt;- allHumanGO$SYMBOL[allHumanGO$GO %in% "GO:0045087"]
m &lt;- length(intersect(genesIIR, tt$Symbol)) ## incluir sólo genes analizados en el conjunto
k &lt;- length(intersect(genesDE, genesIIR))
t &lt;- matrix(c(k, n-k, m-k, N+k-n-m),
            nrow=2, ncol=2, dimnames=dnames)
t
```

```
##         DE
## CG         sí    no
##   dentro   59   350
##   fuera  1029 18717
```

```r
fisher.test(t, alternative="greater")
```

```
## 
## 	Fisher's Exact Test for Count Data
## 
## data:  t
## p-value = 4.872e-12
## alternative hypothesis: true odds ratio is greater than 1
## 95 percent confidence interval:
##  2.382152      Inf
## sample estimates:
## odds ratio 
##   3.065943
```

---

# El análisis de _Gene Ontology_

* Hay miles de conjuntos de genes definidos por los términos GO.


```r
length(unique(allHumanGO$GO))
```

```
## [1] 18349
```

* Existen múltiples paquetes de R disponibles en
[CRAN](https://cran.r-project.org) y [Bioconductor](https://bioconductor.org)
que permiten llevar a cabo un análisis de enriquecimiento funcional automáticamente
para todos los términos GO.

* Aquí ilustraremos este tipo de análisis con el paquete
[GOstats](https://bioconductor.org/packages/GOstats).


```r
library(GOstats)
```

* Con
[GOstats](https://bioconductor.org/packages/GOstats)
el análisis consiste de los siguientes tres pasos:

  1. Construir un **objeto** de parámetros que especifican información como cuál es
  el universo de los genes, que genes consideramos DE, etc.
  2. Ejecutar el análisis de enriquecimiento funcional.
  3. Almacenar y visualizar los resultados.
  
---

class: small-code

# El análisis de _Gene Ontology_

* Construimos un objeto de parámetros utilizando identificadores
[Entrez Gene](https://doi.org/10.1093/nar/gkl993) para los genes:


```r
universoEntrez &lt;- rownames(tt)
genesDEentrez &lt;- rownames(tt)[tt$adj.P.Val &lt; 0.01 &amp; abs(tt$logFC) &gt; log2(1.5)]
params &lt;- new("GOHyperGParams", geneIds=genesDEentrez, universeGeneIds=universoEntrez,
              annotation="org.Hs.eg.db", ontology="BP", pvalueCutoff=0.01)
```

* Ejecutamos el análisis de enriquecimiento funcional (dura unos minutos).


```r
hgOver &lt;- hyperGTest(params)
hgOver
```

```
## Gene to GO BP  test for over-representation 
## 8183 GO BP ids tested (1394 have p &lt; 0.01)
## Selected gene set size: 1005 
##     Gene universe size: 15704 
##     Annotation package: org.Hs.eg
```

* Almacenamos y visualizamos los [resultados](analisisGO.html).


```r
htmlReport(hgOver, file="analisisGO.html")
```

```r
browseURL("analisisGO.html")
```

---

class: small-code

# El análisis de _Gene Ontology_

* El objeto retornado por `hyperGTest()` pertenece la clase
`GOHyperGResult`. La página de ayuda de `HyperGResult-accessors`
contiene información sobre qué métodos se pueden utilizar para
explorar los resultados programáticamente.


```r
help("HyperGResult-accessors")
```

* Un método muy útil es `summary()` ya que nos proporciona un objeto
`data.frame` con los resultados de la prueba exacta de Fisher para cada
término GO que cumple el umbral del `\(p\)`-valor especificado en el objeto
de parámetros.


```r
resHgOver &lt;- summary(hgOver)
dim(resHgOver)
```

```
## [1] 1394    7
```

```r
head(resHgOver, n=3)
```

```
##       GOBPID       Pvalue OddsRatio  ExpCount Count Size
## 1 GO:0002274 1.351230e-40  4.673575  40.44575   140  632
## 2 GO:0006955 1.076723e-39  2.934465 121.40124   269 1897
## 3 GO:0001775 7.561907e-39  3.256114  86.77916   216 1356
##                           Term
## 1 myeloid leukocyte activation
## 2              immune response
## 3              cell activation
```

---

class: small-code

# El análisis de _Gene Ontology_

* Otros métodos de acceso a los resultados son.


```r
head(geneCounts(hgOver))
```

```
## GO:0002274 GO:0006955 GO:0001775 GO:0002376 GO:0006954 GO:0036230 
##        140        269        216        345        145        117
```

```r
head(universeCounts(hgOver))
```

```
## GO:0002274 GO:0006955 GO:0001775 GO:0002376 GO:0006954 GO:0036230 
##        632       1897       1356       2801        705        489
```

```r
head(pvalues(hgOver))
```

```
##   GO:0002274   GO:0006955   GO:0001775   GO:0002376   GO:0006954   GO:0036230 
## 1.351230e-40 1.076723e-39 7.561907e-39 9.113641e-39 4.182159e-38 2.710878e-37
```

```r
length(pvalues(hgOver))
```

```
## [1] 8183
```

* Estos métodos proporcionan los resultados de las pruebas realizadas
**todos** los términos GO, y no solamente a los que tienen un `\(p\)`-valor
debajo del umbral utilizado.

---

class: small-code

# El análisis de _Gene Ontology_

.pull-left[

* La jerarquía de términos GO y sus solapamientos hacen que las pruebas
de hipótesis sean muy dependientes entre ellas.

* Si un término está enriquecido significativamente, es probable que el
término inmediamente superior también lo esté, y sin embargo el término
más específico siempre será más relevante.

* Una solución consiste en analizar de los términos más específicos a los
más generales, eliminando los genes que enriquecen un término significativo,
del término inmediatamente más general en la jerarquía
([Alexa et al., 2006](https://doi.org/10.1093/bioinformatics/btl140)).

]

.pull-right[
&lt;img width="100%" src="img/GOinnateimmuneresponse.png"/&gt;
]

---

class: small-code

# El análisis de _Gene Ontology_

* En el paquete
[GOstats](https://bioconductor.org/packages/GOstats)
esta estrategia se puede utilizar configurando el argumento
`conditional=TRUE` en el objeto de parámetros.


```r
conditional(params) &lt;- TRUE
```

* Luego procedimos exactamente igual que hicimos antes.


```r
hgOverCond &lt;- hyperGTest(params)
hgOverCond
```

```
## Gene to GO BP Conditional test for over-representation 
## 8183 GO BP ids tested (764 have p &lt; 0.01)
## Selected gene set size: 1005 
##     Gene universe size: 15704 
##     Annotation package: org.Hs.eg
```

```r
htmlReport(hgOverCond, file="analisisGOcondicional.html")
```

* En esta nueva [tabla de resultados](analisisGOcondicional.html),
el número de términos GO significativos es menor que cuando utilizamos
la prueba _incondicional_ (`conditional=FALSE`).

---

class: small-code

# El análisis de _Gene Ontology_

* Los términos GO anotados en pocos genes (e.g., `\(m &lt; 3\)`) o enriquecidos
también por pocos genes (e.g., `\(k &lt; 3\)`) son menos fiables que los que
involucran más genes. Por otro lado, los términos GO anotados a muchos
genes (e.g., `\(m &gt; 300\)`) pueden ser demasiado generales para resultar
útiles.

* Para intentar identificar los términos GO enriquecidos más interesantes
y fiables podemos filtrar los resultados de la siguiente forma.


```r
resGO &lt;- summary(hgOverCond)
resGO &lt;- resGO[resGO$Size &gt;= 5 &amp; resGO$Size &lt;= 300 &amp; resGO$Count &gt;= 5, ]
resGO &lt;- resGO[order(resGO$OddsRatio, decreasing=TRUE), ]
head(resGO)
```

```
##         GOBPID       Pvalue OddsRatio  ExpCount Count Size
## 81  GO:1902563 1.075580e-07  29.47844 0.7679572     8   12
## 117 GO:0010273 2.565881e-06  20.61283 0.7679572     7   12
## 211 GO:0010911 1.077893e-04  18.36875 0.5759679     5    9
## 212 GO:1903011 1.077893e-04  18.36875 0.5759679     5    9
## 77  GO:0045730 5.755868e-08  16.47811 1.2108852    10   19
## 234 GO:0002523 2.017034e-04  14.73521 0.6382979     5   10
##                                                      Term
## 81                    regulation of neutrophil activation
## 117                          detoxification of copper ion
## 211                      regulation of isomerase activity
## 212               negative regulation of bone development
## 77                                      respiratory burst
## 234 leukocyte migration involved in inflammatory response
```

---

class: small-code

# El análisis de _Gene Ontology_

* Mediante el método `geneIdsByCategory()` podemos extraer los genes que
_enriquecen_ cada término GO y pegarlos al resultado de la siguiente manera.


```r
idGenes &lt;- geneIdsByCategory(hgOverCond)[resGO$GOBPID]
simGenes &lt;- sapply(idGenes, function(ids) tt[ids, "Symbol"])
simGenes &lt;- sapply(simGenes, paste, collapse=", ")
resGO &lt;- cbind(resGO, Genes=simGenes)
rownames(resGO) &lt;- 1:nrow(resGO)
```

* Podemos generar una tabla de resultados con toda esta información mediante
la funcion `kable` del paquete
[knitr](https://cran.r-project.org/package=knitr) y las funciones
`kable_styling()` y `save_kable()` del paquete
[kableExtra](https://cran.r-project.org/package=kableExtra).


```r
library(knitr)
library(kableExtra)

ktab &lt;- kable(resGO, "html", caption="Resultados análisis GO.", row.names=TRUE)
ktab &lt;- kable_styling(ktab, bootstrap_options=c("stripped", "hover", "responsive"),
                      fixed_thead=TRUE)
save_kable(ktab, file="analisisGOfiltrado.html", self_contained=TRUE)
```

* La tabla de resultados se puede ver a través de este
[enlace](analisisGOfiltrado.html).

---

# Observaciones finales

* Un análisis de enriquecimiento funcional es una manera fácil de
abordar la cuestión de qué vías biológicas pueden estar DE.

* Este tipo de técnicas están limitadas por la cantidad de genes DE
que podemos obtener de nuestros datos.

* El número total de genes involucrados en los cálculos
(el _universo de los genes_) tiene influencia en el `\(p\)`-valor de la
prueba exacta de Fisher.

* Cuando hacemos un análisis de GO puede ser importante hacerlo teniendo en
cuenta la estructura jerárquica de la ontología de GO.

* Las bases de datos de conjuntos de genes no siempre pueden contener
aquellos conjuntos más relevantes a la biología del sistema que estamos
estudiando.

---

class: small-code

# Session information


```r
sessionInfo()
```

```
## R version 4.0.3 (2020-10-10)
## Platform: x86_64-apple-darwin17.0 (64-bit)
## Running under: macOS Catalina 10.15.7
## 
## Matrix products: default
## BLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] parallel  stats4    stats     graphics  grDevices utils     datasets 
## [8] methods   base     
## 
## other attached packages:
##  [1] kableExtra_1.3.4     knitr_1.33           GOstats_2.56.0      
##  [4] graph_1.68.0         Category_2.56.0      Matrix_1.3-2        
##  [7] GO.db_3.12.1         org.Hs.eg.db_3.12.0  AnnotationDbi_1.52.0
## [10] IRanges_2.24.1       S4Vectors_0.28.1     Biobase_2.50.0      
## [13] BiocGenerics_0.36.1  colorout_1.2-2      
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_1.0.6             svglite_2.0.0          lattice_0.20-41       
##  [4] digest_0.6.27          mime_0.10              R6_2.5.0              
##  [7] RSQLite_2.2.7          evaluate_0.14          httr_1.4.2            
## [10] xaringan_0.21          highr_0.9              rlang_0.4.11          
## [13] rstudioapi_0.13        annotate_1.68.0        Rgraphviz_2.34.0      
## [16] jquerylib_0.1.3        blob_1.2.1             rmarkdown_2.8         
## [19] splines_4.0.3          webshot_0.5.2          servr_0.22            
## [22] stringr_1.4.0          munsell_0.5.0          RCurl_1.98-1.3        
## [25] bit_4.0.4              compiler_4.0.3         httpuv_1.6.1          
## [28] xfun_0.23              systemfonts_1.0.1      pkgconfig_2.0.3       
## [31] htmltools_0.5.1.1      codetools_0.2-18       XML_3.99-0.6          
## [34] viridisLite_0.3.0      AnnotationForge_1.32.0 later_1.2.0           
## [37] bitops_1.0-7           grid_4.0.3             RBGL_1.66.0           
## [40] jsonlite_1.7.2         xtable_1.8-4           GSEABase_1.52.1       
## [43] lifecycle_1.0.0        DBI_1.1.1              magrittr_2.0.1        
## [46] scales_1.1.1           stringi_1.6.2          cachem_1.0.4          
## [49] genefilter_1.72.1      promises_1.2.0.1       xml2_1.3.2            
## [52] bslib_0.2.4            vctrs_0.3.8            tools_4.0.3           
## [55] bit64_4.0.5            glue_1.4.2             fastmap_1.1.0         
## [58] survival_3.2-10        yaml_2.2.1             colorspace_2.0-0      
## [61] rvest_1.0.0            memoise_2.0.0          sass_0.3.1
```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create();
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
