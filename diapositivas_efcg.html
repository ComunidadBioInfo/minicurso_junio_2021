<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Mini curso: Análisis de enriquecimiento funcional de conjuntos de genes en R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Robert Castelo" />
    <script src="diapositivas_efcg_files/header-attrs/header-attrs.js"></script>
    <link href="diapositivas_efcg_files/remark-css/default.css" rel="stylesheet" />
    <link href="diapositivas_efcg_files/remark-css/default-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




class: inverse, center, middle
background-image: url(img/portada_curso.jpg)
background-size: contain

---

class: title-slide, middle, center

# Mini curso: Análisis de enriquecimiento funcional de conjuntos de genes en R

.large[Robert Castelo]

.large[robert.castelo@upf.edu | @robertclab]

.large[Universidad Pompeu Fabra | Barcelona]

&lt;img style="width:70px" src="img/logoUPFsmall.png"/&gt;

---

# Vías biológicas diferencialmente expresadas

* La interpretación de una lista de genes diferencialmente expresados (DE) suele ser más util cuando la hacemos en términos de vías biológicas (_biological pathways_).

* Una **vía biológica** es una serie de acciones entre moléculas de una célula que conduce a un determinado producto o a un cambio en la célula; vean la página educacional correspondiente del
[NHGRI](https://www.genome.gov/es/about-genomics/fact-sheets/Vias-Biologicas) para una descripción más ámplia.

* Dado que los genes actúan colectivamente bajo el control de programas de regulación molecular, un modelo
más cercano a la biología subyacente es aquel en que las vías biológicas son las que se expresan diferencialmente.

* Una aproximación sería intentar hacer el análisis de expresión diferencial **directamente** a nivel de vía
biológica, o **indirectamente** buscando la sobre-representación (enriquecimiento) de nuestros genes DE en
cada vía de **interés**.

---

# Definiciones de vías biológicas

* Consideremos primero restrigir la búsqueda de vías biológicas DE a aquellas que son conocidas.

* Bases de datos como [Reactome](https://www.reactome.org) o [KEGG](https://www.genome.jp/kegg)
anotan información de la literatura sobre los genes, la proteinas and las reacciones que forman
las vías biológicas.

* Una forma simple pero muy útil de definir vías biológicas es en terminos de **conjuntos de genes**,
irrespectivamente de las interacciones moleculares que pueda haber entre ellos y/o sus productos.

* Hay muchas bases de datos de conjuntos de genes, siendo las más populares
[The Gene Ontology (GO) project](http://geneontology.org) y
[The Molecular Signatures Database (MSigDB)](https://www.gsea-msigdb.org/gsea/msigdb).

* A menudo las bases de datos no incluyen las vías biológicas que són más relevantes al sistema
que estamos estudiando. En tal caso, deberíamos de o bien curar nuestros propios conjuntos de genes,
o bien utilizar técnicas para inferirlos a partir de los datos.

---

# Definiciones de vías biológicas

* Por ejemplo, piensen en genes que codifican por proteinas involucradas en la respuesta inmune innata.
Concretamente, aquellos q detectan patógenos humanos.


.center2[
&lt;img style="margin-top:20%" src="img/TLRs.jpg" width="400px"/&gt;
]

.footnote[Fig. 1. Christmas P. Toll-Like Receptors: Sensors that Detect Infection. &lt;a href="https://www.nature.com/scitable/topicpage/toll-like-receptors-sensors-that-detect-infection-14396559#"&gt;&lt;em&gt;Nature Education&lt;/em&gt;, 3(9):85, 2010.&lt;/a&gt;]

---

# Idea general del enriquecimiento functional

* Teniendo en mente la definición de la vía biológica previa, qué podríamos concluir a partir de la siguiente
gráfica de tipo volcán?

.center2[
&lt;img style="margin-top:25%" src="img/CostaCastelo16fig1a.png" width="350px"/&gt;
]

.footnote[Fig. 1a. Costa D and Castelo R. Umbilical cord gene expression reveals the molecular architecture of the fetal inflammatory response in extremely preterm newborns. &lt;a href="https://dx.doi.org/10.1038/pr.2015.233"&gt;&lt;em&gt;Pediatric Research&lt;/em&gt;, 79:473-481, 2016.&lt;/a&gt;]

---

# Idea general del enriquecimiento functional

* Una forma conveniente de encontrar vías biológicas DE, en términos de conjuntos de genes DE, es detectando
lo que se suele llamar un **enriquecimiento funcional** a través de los siguientes dos pasos:
  &lt;br&gt;
  1. Buscar genes DE.
  2. Para cada conjunto de genes, verificar si esos genes DE pertenecen a ese conjunto
     en una proporción que excede cualquier expectativa de encontrar ese número de genes
     en ese conjunto únicamente por azar.

* En este contexto, cuando un conjunto de genes contiene **más** genes DE que los que podríamos esperar
por puro azar, decimos que este conjunto de genes esta **enriquecido** en genes DE.

* Una forma fácil de aplicar esta estrategia es utilizando la llamada
[prueba exacta de Fisher ](https://es.wikipedia.org/wiki/Prueba_exacta_de_Fisher)
(también conocida como prueba hipergeométrica).

---

# La prueba exacta de Fisher

* **Hipótesis nula**: el conjunto de genes no incluye más genes DE que los que podríamos esperar únicamente
por azar. Esta hipótesis nula se suele formalizar con el llamado **modelo de la urna**:

.left-column[
&lt;img src="img/RenaissanceUrn.png" style="margin-left:10px; width:100%"&gt;
&lt;img src="img/blackAndWhiteBalls.png" style="margin-left:10px; width:100%"&gt;
]

.right-column[
* Universo de genes: todos los genes que **consideramos**.
* Hay una bola en la urna para cada gen del universo de genes.
* Cada bola está etiquetada con un único identificador de gen.
* Las bolas blancas representan genes **DE**.
* Las bolas negras representan genes **no-DE**.
* Sacar a ciegas (uniformemente al azar) tantas bolas de la urna
  como genes tenemos en el conjunto de genes para el que hacemos la
  prueba, sin volverlas a poner en la urna (muestreo **sin reemplazamiento**).
* El número de **bolas blancas** sacadas de esta manera de la urna (i.e., el número
  de genes DE del conjunto para el que hacemos la prueba) sigue una
  [distribución hipergeométrica](https://es.wikipedia.org/wiki/Distribuci%C3%B3n_hipergeom%C3%A9trica).
]

---

# La prueba exacta de Fisher

* Consideramos las siguientes cantidades:

  * `\(N\)` es el número total de genes __considerados__ (tamaño de nuestro universo de genes).
  * `\(n\)` es el número de genes DE.
  * `\(m\)` es el número de genes del conjunto para el que hacemos la prueba.
  * `\(k\)` es el número de genes DE en el conjunto para el que hacemos la prueba.

* La [prueba exacta de Fisher](https://es.wikipedia.org/wiki/Prueba_exacta_de_Fisher)
se utiliza ampliamente en el análisis de tablas de contingencia resultantes de clasificar
objetos a través de dos factores los cuales en nuestro caso son la pertenencia a un conjunto
de genes y si un gen es DE o no:


GENES               | DE    | no-DE     | Total  
--------------------|-------|-----------|------
DENTRO DEL CONJUNTO |  `\(k\)`  | `\(m-k\)`     | `\(m\)`
FUERA DEL CONJUNTO  | `\(n-k\)` | `\(N+k-n-m\)` | `\(N-m\)`
TOTAL               | `\(n\)`   | `\(N-n\)`     | `\(N\)`

---

# La prueba exacta de Fisher

* Dados los valores `\(N\)`, `\(n\)`, `\(m\)` y `\(k\)` y una variable aleatoria `\(X\)` representando los posibles
resultados del experimento con la urna, la probabilidad de observar exactamente `\(k\)` genes en el
conjunto de genes para el que hacemos la prueba es:

$$ \textrm{Pr}(X=k) = \frac{ {m \choose k} {N-m \choose n-k} }{ N \choose n }\,. $$

* La probabilidad de observar `\(k\)` **o más** genes DE en un conjunto de genes bajo la hipótesis
nula es:

$$ \textrm{Pr}(X &gt;= k)=\sum_{x=k}^{\textrm{min}(m, n)} \frac{ {m\choose x} {N-m\choose n-x} }{ {N\choose n} }\,. $$
* Esta probabilidad corresponde al `\(p\)`-valor de una
[prueba exacta de Fisher](https://es.wikipedia.org/wiki/Prueba_exacta_de_Fisher) unilateral (_one-tailed_)
para la hipótesis nula de no-asociación entre dos factores.

* Este es el `\(p\)`-valor para la hipótesis nula de no-enriquecimiento de genes
DE en el conjunto de genes. Cuanto menor sea el `\(p\)`-valor, menos consistente con el puro azar
será la observación de los `\(k\)` genes DE en el conjunto.

---

class: small-code

# La prueba exacta de Fisher

* Recordemos la fórmula de la probabilidad de observar `\(k\)` **o mas** genes DE en un conjunto de genes bajo
la hipótesis nula:

$$ \textrm{Pr}(X &gt;= k)=\sum_{x=k}^{\textrm{min}\{m, n\}} \frac{ {m\choose x} {N-m\choose n-x} }{ {N\choose n} }\,. $$

* Consideremos un ejemplo de juguete donde tenemos unos datos de expresión génica para `\(N=10\)` genes,
de los cuales `\(m=4\)` pertenecen a un conjunto de genes de nuestro interés y donde identificamos `\(n=2\)`
genes como DE. Supongamos que entre los `\(n=2\)` genes DE hay `\(k=1\)` que pertenece al conjunto de genes.
Cuál sería el `\(p\)`-valor que nos dice si este conjunto de genes esta enriquecido significativamente en
genes DE?


```r
N &lt;- 10
m &lt;- 4
n &lt;- 2
k &lt;- 1
choose(m, 1) * choose(N-m, n-1) / choose(N, n) + choose(m, 2) * choose(N-m, n-2) / choose(N, n)
```

```
## [1] 0.6666667
```

---

class: small-code

# La prueba exacta de Fisher

* El cálculo anterior lo podemos hacer directamente utilizando la función de R `phyper()` para
calcular la masa de la distribución hipergeométrica de la siguiente forma:


```r
phyper(k-1, m, N-m, n, lower.tail=FALSE)
```

```
## [1] 0.6666667
```

* Esto nos permite jugar facilmente con las cantidades involucradas en este cálculo, por ejemplo
aumentando el número de genes `\(N\)` en nuestros datos de expresión.


```r
N &lt;- 11
phyper(k-1, m, N-m, n, lower.tail=FALSE)
```

```
## [1] 0.6181818
```

```r
N &lt;- 12
phyper(k-1, m, N-m, n, lower.tail=FALSE)
```

```
## [1] 0.5757576
```

```r
N &lt;- 13
phyper(k-1, m, N-m, n, lower.tail=FALSE)
```

```
## [1] 0.5384615
```

---

class: small-code

# La prueba exacta de Fisher

* El `\(p\)`-valor de la prueba depende del tamaño `\(N\)` del universo de los genes!


```r
pn &lt;- sapply(10:400, function(N) phyper(k-1, m, N-m, n, lower.tail=FALSE))
plot(10:400, pn, type="l", xlab="N", ylab="Pr(X&gt;=k)", las=1, lwd=2, cex.axis=1.2, cex.lab=1.5)
abline(h=0.05, lty=3, lwd=2, col="red")
```

&lt;img src="diapositivas_efcg_files/figure-html/universeByN-1.png" height="400px" style="display: block; margin: auto;" /&gt;

---

class: small-code

# La prueba exacta de Fisher

.pull-left[
* La función de R `fisher.test()` nos permite hacer la prueba exacta unilateral de Fisher de la
siguiente manera.

* Consideramos la organización previa de la tabla de contingencia de genes DE y de pertenecia a
un conjunto de genes:

.small-table[

GENES               | DE    | no-DE     | Total  
--------------------|-------|-----------|------
DENTRO DEL CONJUNTO |  `\(k\)`  | `\(m-k\)`     | `\(m\)`
FUERA DEL CONJUNTO  | `\(n-k\)` | `\(N+k-n-m\)` | `\(N-m\)`
TOTAL               | `\(n\)`   | `\(N-n\)`     | `\(N\)`

]

* Para llevar a cabo la prueba exacta de Fisher de forma **unilateral**, debemos utilizar el
parámetro `alternative="greater"`.
]

.pull-right[

```r
N &lt;- 10
dnames &lt;- list(CG=c("dentro","fuera"),
               DE=c("sí","no"))
t &lt;- matrix(c(k, n-k, m-k, N+k-n-m),
            nrow=2, ncol=2, dimnames=dnames)
t
```

```
##         DE
## CG       sí no
##   dentro  1  3
##   fuera   1  5
```

```r
fisher.test(t, alternative="greater")
```

```
## 
## 	Fisher's Exact Test for Count Data
## 
## data:  t
## p-value = 0.6667
## alternative hypothesis: true odds ratio is greater than 1
## 95 percent confidence interval:
##  0.03262857        Inf
## sample estimates:
## odds ratio 
##   1.581082
```
]

---

# El análisis de _Gene Ontology_

* Un _análisis de Gene Ontology (GO)_ es un análisis de enriquecimiento funcional
aplicado a cada uno de los conjuntos de genes de la
[base de datos de GO](http://geneontology.org).

* La [base de datos de GO](http://geneontology.org) proporciona un vocabulario
controlado para describir atributos de genes y sus productos para cualquier organismo.
Consiste de los llamados **términos GO**, los cuales are pares de identificador de
término (GO ID) y su descripción.

|     GO ID | Descripción           |
|-----------|-----------------------|
|GO:0045087 | innate immune response|
|GO:0006955 | immune response       |
|GO:0006950 | response to stress    |

* Un término GO pertenece a una de las siguientes tres ontologías: _Biological Process (BP)_,
_Molecular Function (MF)_ y _Cellular Component (CC)_.

* El producto de un gen puede asociarse con o localizarse en uno o más **componentes celulares**
y estar activo en uno o más **procesos biológicos** durante los cuales realiza una o más
**funciones moleculares**.

---

# El análisis de _Gene Ontology_

.pull-left[

* Dentro de una ontología, los términos GO estan relacionados unos con otros a través de relaciones
jerárquicas que describen cuándo un término GO es más general que otro más específico.

* Detalles en este u otros aspectos están descritos en
[http://geneontology.org/docs/ontology-documentation](http://geneontology.org/docs/ontology-documentation)

* Para poder llevar a cabo un análisis de GO necesitamos anotaciones sobre los genes que nos
digan a qué términos GO están asociados.

]

.pull-right[
&lt;img width="100%" src="img/GOinnateimmuneresponse.png"/&gt;
]

---

class: small-code

# El análisis de _Gene Ontology_

* El paquete de Bioconductor [org.Hs.eg.db](https://bioconductor.org/packages/org.Hs.eg.db) contiene
anotaciones diversas para los genes humanos, incluyendo anotaciones de términos GO.


```r
library(org.Hs.eg.db)
allHumanGO &lt;- select(org.Hs.eg.db, columns="GO", key=keys(org.Hs.eg.db, keytype="SYMBOL"),
                     keytype="SYMBOL")
dim(allHumanGO)
```

```
## [1] 379747      4
```

```r
head(allHumanGO, n=3)
```

```
##   SYMBOL         GO EVIDENCE ONTOLOGY
## 1   A1BG GO:0002576      TAS       BP
## 2   A1BG GO:0003674       ND       MF
## 3   A1BG GO:0005576      HDA       CC
```

* Las anotaciones de términos GO sobre los genes incluyen la trazabilidad del origen de la
anotación mediante los [códigos de evidencia](http://geneontology.org/docs/guide-go-evidence-codes).


```r
sort(table(allHumanGO$EVIDENCE), decreasing=TRUE)
```

```
## 
##   IEA   IDA   IBA   TAS   ISS   IMP   IPI   HDA   NAS    ND   IGI   ISA    IC 
## 75662 67065 65238 42573 25859 21384 18230  7571  6701  1811  1802  1485  1242 
##   IEP   ISM   EXP   HMP   RCA   HEP   ISO   IGC 
##   880   723   299   154   143    70     8     1
```

---

class: small-code

# Session information


```r
sessionInfo()
```

```
## R version 4.0.3 (2020-10-10)
## Platform: x86_64-apple-darwin17.0 (64-bit)
## Running under: macOS Catalina 10.15.7
## 
## Matrix products: default
## BLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] parallel  stats4    stats     graphics  grDevices utils     datasets 
## [8] methods   base     
## 
## other attached packages:
## [1] org.Hs.eg.db_3.12.0  AnnotationDbi_1.52.0 IRanges_2.24.1      
## [4] S4Vectors_0.28.1     Biobase_2.50.0       BiocGenerics_0.36.1 
## [7] colorout_1.2-2      
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_1.0.6        bslib_0.2.4       compiler_4.0.3    later_1.2.0      
##  [5] jquerylib_0.1.3   highr_0.9         tools_4.0.3       digest_0.6.27    
##  [9] bit_4.0.4         memoise_2.0.0     jsonlite_1.7.2    evaluate_0.14    
## [13] RSQLite_2.2.7     pkgconfig_2.0.3   rlang_0.4.11      DBI_1.1.1        
## [17] rstudioapi_0.13   yaml_2.2.1        xfun_0.23         fastmap_1.1.0    
## [21] stringr_1.4.0     knitr_1.33        vctrs_0.3.8       sass_0.3.1       
## [25] bit64_4.0.5       R6_2.5.0          rmarkdown_2.8     xaringan_0.21    
## [29] blob_1.2.1        magrittr_2.0.1    servr_0.22        promises_1.2.0.1 
## [33] htmltools_0.5.1.1 mime_0.10         httpuv_1.6.1      stringi_1.6.2    
## [37] cachem_1.0.4
```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create();
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
